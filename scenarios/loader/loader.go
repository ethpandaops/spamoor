// Package loader provides dynamic scenario loading using Yaegi.
package loader

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"

	"github.com/ethpandaops/spamoor/scenario"
	"github.com/sirupsen/logrus"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
)

// ScenarioLoader handles loading scenarios from Go source files at runtime.
type ScenarioLoader struct {
	logger *logrus.Entry
}

// NewScenarioLoader creates a new scenario loader.
func NewScenarioLoader(logger logrus.FieldLogger) *ScenarioLoader {
	return &ScenarioLoader{
		logger: logger.WithField("component", "scenario-loader"),
	}
}

// newInterpreter creates a new Yaegi interpreter with all necessary symbols loaded.
func (l *ScenarioLoader) newInterpreter() *interp.Interpreter {
	i := interp.New(interp.Options{})

	// Load standard library symbols
	if err := i.Use(stdlib.Symbols); err != nil {
		l.logger.Warnf("failed to load stdlib symbols: %v", err)
	}

	// Load spamoor package symbols (generated by yaegi extract)
	if err := i.Use(Symbols); err != nil {
		l.logger.Warnf("failed to load spamoor symbols: %v", err)
	}

	return i
}

// LoadFromFile loads a scenario from a single Go source file.
// The file must define a variable named 'ScenarioDescriptor' of type scenario.Descriptor.
func (l *ScenarioLoader) LoadFromFile(path string) (*scenario.Descriptor, error) {
	// Read the source file
	source, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read scenario file: %w", err)
	}

	// Create a new interpreter for this scenario
	i := l.newInterpreter()

	// Evaluate the source code
	_, err = i.Eval(string(source))
	if err != nil {
		return nil, fmt.Errorf("failed to evaluate scenario: %w", err)
	}

	// Try to get the ScenarioDescriptor variable
	v, err := i.Eval("ScenarioDescriptor")
	if err != nil {
		return nil, fmt.Errorf("scenario must export 'ScenarioDescriptor' variable: %w", err)
	}

	// Extract the descriptor
	desc, ok := extractDescriptor(v)
	if !ok {
		return nil, fmt.Errorf("ScenarioDescriptor is not of type scenario.Descriptor (got %T)", v.Interface())
	}

	l.logger.Infof("loaded dynamic scenario: %s from %s", desc.Name, filepath.Base(path))
	return desc, nil
}

// LoadFromDir loads all scenarios from .go files in a directory.
// Files that fail to load are logged and skipped.
func (l *ScenarioLoader) LoadFromDir(dir string) []*scenario.Descriptor {
	var descriptors []*scenario.Descriptor

	// Find all .go files in the directory
	pattern := filepath.Join(dir, "*.go")
	files, err := filepath.Glob(pattern)
	if err != nil {
		l.logger.Warnf("failed to glob scenario directory: %v", err)
		return descriptors
	}

	if len(files) == 0 {
		l.logger.Debugf("no .go files found in %s", dir)
		return descriptors
	}

	for _, f := range files {
		desc, err := l.LoadFromFile(f)
		if err != nil {
			l.logger.Warnf("failed to load scenario from %s: %v", filepath.Base(f), err)
			continue
		}
		descriptors = append(descriptors, desc)
	}

	l.logger.Infof("loaded %d dynamic scenario(s) from %s", len(descriptors), dir)
	return descriptors
}

// extractDescriptor attempts to extract a scenario.Descriptor from a reflect.Value.
func extractDescriptor(v reflect.Value) (*scenario.Descriptor, bool) {
	if !v.IsValid() {
		return nil, false
	}

	// Handle pointer types
	if v.Kind() == reflect.Ptr {
		v = v.Elem()
	}

	// Try direct type assertion on the interface
	iface := v.Interface()

	// Check if it's already a *scenario.Descriptor
	if desc, ok := iface.(*scenario.Descriptor); ok {
		return desc, true
	}

	// Check if it's a scenario.Descriptor value
	if desc, ok := iface.(scenario.Descriptor); ok {
		return &desc, true
	}

	return nil, false
}
