// Package loader provides dynamic scenario loading using Yaegi.
package loader

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/ethpandaops/spamoor/scenario"
	"github.com/sirupsen/logrus"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
)

// ScenarioLoader handles loading scenarios from Go source files at runtime.
type ScenarioLoader struct {
	logger *logrus.Entry
}

// NewScenarioLoader creates a new scenario loader.
func NewScenarioLoader(logger logrus.FieldLogger) *ScenarioLoader {
	return &ScenarioLoader{
		logger: logger.WithField("component", "scenario-loader"),
	}
}

// newInterpreter creates a new Yaegi interpreter with all necessary symbols loaded.
func (l *ScenarioLoader) newInterpreter() *interp.Interpreter {
	i := interp.New(interp.Options{})

	// Load standard library symbols
	if err := i.Use(stdlib.Symbols); err != nil {
		l.logger.Warnf("failed to load stdlib symbols: %v", err)
	}

	// Load spamoor package symbols (generated by yaegi extract)
	if err := i.Use(Symbols); err != nil {
		l.logger.Warnf("failed to load spamoor symbols: %v", err)
	}

	return i
}

// LoadFromFile loads a scenario from a single Go source file.
// The file must define a variable named 'ScenarioDescriptor' of type scenario.Descriptor.
func (l *ScenarioLoader) LoadFromFile(path string) (*scenario.Descriptor, error) {
	filename := filepath.Base(path)

	// Read the source file
	source, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read scenario file %s: %w", filename, err)
	}

	// Create a new interpreter for this scenario
	i := l.newInterpreter()

	// Evaluate the source code
	_, err = i.Eval(string(source))
	if err != nil {
		return nil, l.wrapEvalError(filename, err)
	}

	// Try to get the ScenarioDescriptor variable
	v, err := i.Eval("ScenarioDescriptor")
	if err != nil {
		return nil, fmt.Errorf("scenario %s must export 'ScenarioDescriptor' variable: %w", filename, err)
	}

	// Extract the descriptor
	desc, ok := extractDescriptor(v)
	if !ok {
		return nil, fmt.Errorf("ScenarioDescriptor in %s is not of type scenario.Descriptor (got %T)", filename, v.Interface())
	}

	l.logger.Infof("loaded dynamic scenario: %s from %s", desc.Name, filename)
	return desc, nil
}

// wrapEvalError wraps Yaegi evaluation errors with helpful hints.
func (l *ScenarioLoader) wrapEvalError(filename string, err error) error {
	errStr := err.Error()

	// Try to detect missing symbols and suggest yaegi extract
	if strings.Contains(errStr, "undefined:") {
		// Parse error like: undefined: "github.com/some/package".Function
		// or: 1:2: undefined: packagename
		re := regexp.MustCompile(`undefined: "([^"]+)"\.(\w+)`)
		matches := re.FindStringSubmatch(errStr)
		if len(matches) == 3 {
			pkg := matches[1]
			symbol := matches[2]
			return fmt.Errorf("failed to evaluate scenario %s: missing symbol %s.%s\n"+
				"Hint: The package %q may not have extracted symbols.\n"+
				"Run: cd scenarios/loader && yaegi extract %s\n"+
				"Then: perl -i -pe 's/^package \\w+$/package loader/' scenarios/loader/symbols_*.go",
				filename, pkg, symbol, pkg, pkg)
		}

		// Simpler undefined pattern
		simpleRe := regexp.MustCompile(`undefined: (\w+)`)
		simpleMatches := simpleRe.FindStringSubmatch(errStr)
		if len(simpleMatches) == 2 {
			return fmt.Errorf("failed to evaluate scenario %s: %w (hint: symbol %q is undefined, check imports and ensure all required packages have extracted symbols)",
				filename, err, simpleMatches[1])
		}
	}

	// Detect CFG/panic errors (Yaegi internal issues)
	if strings.Contains(errStr, "CFG") || strings.Contains(errStr, "panic") {
		return fmt.Errorf("failed to evaluate scenario %s: %w\n"+
			"Hint: This may be a Yaegi interpreter limitation.\n"+
			"Common causes:\n"+
			"  - Channel sends to custom type aliases in closures (use raw channel type)\n"+
			"  - Complex type assertions\n"+
			"  - Unsupported language features",
			filename, err)
	}

	// Detect type-related errors
	if strings.Contains(errStr, "type") && (strings.Contains(errStr, "cannot") || strings.Contains(errStr, "mismatch")) {
		return fmt.Errorf("failed to evaluate scenario %s: %w (hint: type mismatch detected, ensure types match the extracted symbols exactly)",
			filename, err)
	}

	// Detect import errors
	if strings.Contains(errStr, "import") || strings.Contains(errStr, "could not import") {
		return fmt.Errorf("failed to evaluate scenario %s: %w (hint: import failed, check that all imported packages have been extracted with 'yaegi extract', run 'make generate-symbols' to regenerate)",
			filename, err)
	}

	// Generic error with general hint
	return fmt.Errorf("failed to evaluate scenario %s: %w (hint: run 'spamoor validate-scenario %s' for detailed diagnostics)",
		filename, err, filename)
}

// LoadFromDir loads all scenarios from .go files in a directory.
// Files that fail to load are logged and skipped.
func (l *ScenarioLoader) LoadFromDir(dir string) []*scenario.Descriptor {
	var descriptors []*scenario.Descriptor
	var failedCount int

	// Find all .go files in the directory
	pattern := filepath.Join(dir, "*.go")
	files, err := filepath.Glob(pattern)
	if err != nil {
		l.logger.Errorf("failed to glob scenario directory %s: %v", dir, err)
		return descriptors
	}

	if len(files) == 0 {
		l.logger.Debugf("no .go files found in %s", dir)
		return descriptors
	}

	for _, f := range files {
		desc, err := l.LoadFromFile(f)
		if err != nil {
			l.logger.Warnf("failed to load scenario from %s: %v", filepath.Base(f), err)
			failedCount++
			continue
		}
		descriptors = append(descriptors, desc)
	}

	if failedCount > 0 {
		l.logger.Warnf("loaded %d dynamic scenario(s) from %s (%d failed to load)", len(descriptors), dir, failedCount)
	} else {
		l.logger.Infof("loaded %d dynamic scenario(s) from %s", len(descriptors), dir)
	}
	return descriptors
}

// extractDescriptor attempts to extract a scenario.Descriptor from a reflect.Value.
func extractDescriptor(v reflect.Value) (*scenario.Descriptor, bool) {
	if !v.IsValid() {
		return nil, false
	}

	// Handle pointer types
	if v.Kind() == reflect.Ptr {
		v = v.Elem()
	}

	// Try direct type assertion on the interface
	iface := v.Interface()

	// Check if it's already a *scenario.Descriptor
	if desc, ok := iface.(*scenario.Descriptor); ok {
		return desc, true
	}

	// Check if it's a scenario.Descriptor value
	if desc, ok := iface.(scenario.Descriptor); ok {
		return &desc, true
	}

	return nil, false
}
