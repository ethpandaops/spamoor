package evmfuzz

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/core/types"
	"github.com/holiman/uint256"
	"github.com/sirupsen/logrus"
	"github.com/spf13/pflag"

	"github.com/ethpandaops/spamoor/scenario"
	"github.com/ethpandaops/spamoor/spamoor"
	"github.com/ethpandaops/spamoor/txbuilder"
	"github.com/ethpandaops/spamoor/utils"
)

type ScenarioOptions struct {
	TotalCount  uint64  `yaml:"total_count"`
	Throughput  uint64  `yaml:"throughput"`
	MaxPending  uint64  `yaml:"max_pending"`
	MaxWallets  uint64  `yaml:"max_wallets"`
	Rebroadcast uint64  `yaml:"rebroadcast"`
	BaseFee     float64 `yaml:"base_fee"`
	TipFee      float64 `yaml:"tip_fee"`
	GasLimit    uint64  `yaml:"gas_limit"`
	Timeout     string  `yaml:"timeout"`
	ClientGroup string  `yaml:"client_group"`
	LogTxs      bool    `yaml:"log_txs"`

	// EVM Fuzzing specific options
	MaxCodeSize uint64 `yaml:"max_code_size"`
	MinCodeSize uint64 `yaml:"min_code_size"`
	PayloadSeed string `yaml:"payload_seed"` // Optional seed for reproducible fuzzing
	TxIdOffset  uint64 `yaml:"tx_id_offset"` // Start fuzzing from a specific txID
}

type Scenario struct {
	options    ScenarioOptions
	logger     logrus.FieldLogger
	walletPool *spamoor.WalletPool
}

var ScenarioName = "evm-fuzz"
var ScenarioDefaultOptions = ScenarioOptions{
	TotalCount:  0,
	Throughput:  50,
	MaxPending:  100,
	MaxWallets:  0,
	Rebroadcast: 30,
	BaseFee:     20,
	TipFee:      2,
	GasLimit:    1000000,
	Timeout:     "",
	ClientGroup: "",
	LogTxs:      false,
	MaxCodeSize: 512,
	MinCodeSize: 100,
	PayloadSeed: "", // Empty means use random seed
	TxIdOffset:  0,
}

var ScenarioDescriptor = scenario.Descriptor{
	Name:           ScenarioName,
	Description:    "Fuzzes the EVM by deploying contracts with randomly generated bytecode to find consensus bugs",
	DefaultOptions: ScenarioDefaultOptions,
	NewScenario:    newScenario,
}

func newScenario(logger logrus.FieldLogger) scenario.Scenario {
	return &Scenario{
		options: ScenarioDefaultOptions,
		logger:  logger.WithField("scenario", ScenarioName),
	}
}

func (s *Scenario) Flags(flags *pflag.FlagSet) error {
	flags.Uint64VarP(&s.options.TotalCount, "count", "c", ScenarioDefaultOptions.TotalCount, "Total number of contract deployments")
	flags.Uint64VarP(&s.options.Throughput, "throughput", "t", ScenarioDefaultOptions.Throughput, "Number of deployments per slot")
	flags.Uint64Var(&s.options.MaxPending, "max-pending", ScenarioDefaultOptions.MaxPending, "Maximum number of pending transactions")
	flags.Uint64Var(&s.options.MaxWallets, "max-wallets", ScenarioDefaultOptions.MaxWallets, "Maximum number of child wallets to use")
	flags.Uint64Var(&s.options.Rebroadcast, "rebroadcast", ScenarioDefaultOptions.Rebroadcast, "Enable reliable rebroadcast with unlimited retries and exponential backoff")
	flags.Float64Var(&s.options.BaseFee, "basefee", ScenarioDefaultOptions.BaseFee, "Max fee per gas to use in transactions (in gwei)")
	flags.Float64Var(&s.options.TipFee, "tipfee", ScenarioDefaultOptions.TipFee, "Max tip per gas to use in transactions (in gwei)")
	flags.Uint64Var(&s.options.GasLimit, "gaslimit", ScenarioDefaultOptions.GasLimit, "Gas limit to use in transactions")
	flags.StringVar(&s.options.Timeout, "timeout", ScenarioDefaultOptions.Timeout, "Timeout for the scenario (e.g. '1h', '30m', '5s') - empty means no timeout")
	flags.StringVar(&s.options.ClientGroup, "client-group", ScenarioDefaultOptions.ClientGroup, "Client group to use for sending transactions")
	flags.BoolVar(&s.options.LogTxs, "log-txs", ScenarioDefaultOptions.LogTxs, "Log all submitted transactions")

	// EVM Fuzzing specific flags
	flags.Uint64Var(&s.options.MaxCodeSize, "max-code-size", ScenarioDefaultOptions.MaxCodeSize, "Maximum bytecode size")
	flags.Uint64Var(&s.options.MinCodeSize, "min-code-size", ScenarioDefaultOptions.MinCodeSize, "Minimum bytecode size")
	flags.StringVar(&s.options.PayloadSeed, "payload-seed", ScenarioDefaultOptions.PayloadSeed, "Custom hex seed for reproducible fuzzing (e.g. 0x1234abcd, empty means random)")
	flags.Uint64Var(&s.options.TxIdOffset, "tx-id-offset", ScenarioDefaultOptions.TxIdOffset, "Start fuzzing from a specific transaction ID")

	return nil
}

func (s *Scenario) Init(options *scenario.Options) error {
	s.walletPool = options.WalletPool

	if options.Config != "" {
		err := scenario.ParseAndValidateConfig(&ScenarioDescriptor, options.Config, &s.options, s.logger)
		if err != nil {
			return err
		}
	}

	if s.options.MaxWallets > 0 {
		s.walletPool.SetWalletCount(s.options.MaxWallets)
	} else if s.options.TotalCount > 0 {
		maxWallets := s.options.TotalCount / 50
		if maxWallets < 10 {
			maxWallets = 10
		} else if maxWallets > 1000 {
			maxWallets = 1000
		}
		s.walletPool.SetWalletCount(maxWallets)
	} else {
		if s.options.Throughput*10 < 1000 {
			s.walletPool.SetWalletCount(s.options.Throughput * 10)
		} else {
			s.walletPool.SetWalletCount(1000)
		}
	}

	if s.options.TotalCount == 0 && s.options.Throughput == 0 {
		return fmt.Errorf("neither total count nor throughput limit set, must define at least one of them (see --help for list of all flags)")
	}

	if s.options.MinCodeSize > s.options.MaxCodeSize {
		return fmt.Errorf("min code size cannot be larger than max code size")
	}

	if s.options.GasLimit > utils.MaxGasLimitPerTx {
		s.logger.Warnf("Gas limit %d exceeds %d and will most likely be dropped by the execution layer client", s.options.GasLimit, utils.MaxGasLimitPerTx)
	}

	// Validate hex seed format if provided
	if s.options.PayloadSeed != "" {
		if err := s.validateSeed(s.options.PayloadSeed); err != nil {
			return fmt.Errorf("invalid payload seed: %v", err)
		}
	}

	return nil
}

func (s *Scenario) Run(ctx context.Context) error {
	s.logger.Infof("starting scenario: %s", ScenarioName)
	defer s.logger.Infof("scenario %s finished.", ScenarioName)

	maxPending := s.options.MaxPending
	if maxPending == 0 {
		maxPending = s.options.Throughput * 10
		if maxPending == 0 {
			maxPending = 4000
		}

		if maxPending > s.walletPool.GetConfiguredWalletCount()*10 {
			maxPending = s.walletPool.GetConfiguredWalletCount() * 10
		}
	}

	s.logger.WithFields(logrus.Fields{
		"total":      s.options.TotalCount,
		"throughput": s.options.Throughput,
		"maxPending": maxPending,
		"codeSize":   fmt.Sprintf("%d-%d", s.options.MinCodeSize, s.options.MaxCodeSize),
	}).Info("Starting EVM fuzzer scenario - deploying contracts with stack-aware bytecode")

	var timeout time.Duration
	var err error
	if s.options.Timeout != "" {
		timeout, err = time.ParseDuration(s.options.Timeout)
		if err != nil {
			return fmt.Errorf("invalid timeout value: %v", err)
		}
		s.logger.Infof("Timeout set to %v", timeout)
	}

	err = scenario.RunTransactionScenario(ctx, scenario.TransactionScenarioOptions{
		TotalCount: s.options.TotalCount,
		Throughput: s.options.Throughput,
		MaxPending: maxPending,
		Timeout:    timeout,
		WalletPool: s.walletPool,
		Logger:     s.logger.(*logrus.Entry),
		ProcessNextTxFn: func(ctx context.Context, params *scenario.ProcessNextTxParams) error {
			logger := s.logger
			receiptChan, tx, client, wallet, err := s.deployFuzzedContract(ctx, params.TxIdx)
			if client != nil {
				logger = logger.WithField("rpc", client.GetName())
			}
			if tx != nil {
				logger = logger.WithField("nonce", tx.Nonce())
			}
			if wallet != nil {
				logger = logger.WithField("wallet", s.walletPool.GetWalletName(wallet.GetAddress()))
			}

			params.NotifySubmitted()
			params.OrderedLogCb(func() {
				if err != nil {
					logger.Warnf("fuzz contract %6d.0 failed: %v", params.TxIdx+1, err)
				} else if s.options.LogTxs {
					logger.Infof("fuzz contract %6d.0 sent:  %v (%d bytes)", params.TxIdx+1, tx.Hash().String(), len(tx.Data()))
				} else {
					logger.Debugf("fuzz contract %6d.0 sent:  %v (%d bytes)", params.TxIdx+1, tx.Hash().String(), len(tx.Data()))
				}
			})

			// wait for receipt
			if receiptChan != nil {
				if receipt, err := receiptChan.Wait(ctx); err != nil {
					return err
				} else if receipt != nil {
					// Log interesting deployment results
					if receipt.Status == types.ReceiptStatusSuccessful {
						logger.Debugf("contract deployed at %v, gas used: %d", receipt.ContractAddress.Hex(), receipt.GasUsed)
					} else {
						logger.Debugf("contract deployment failed, gas used: %d", receipt.GasUsed)
					}
				}
			}

			return err
		},
	})

	return err
}

func (s *Scenario) deployFuzzedContract(ctx context.Context, txIdx uint64) (scenario.ReceiptChan, *types.Transaction, *spamoor.Client, *spamoor.Wallet, error) {
	// Generate fuzzed bytecode for contract deployment
	fuzzedBytecode := s.generateFuzzedBytecode(txIdx)

	// Select wallet and client
	wallet := s.walletPool.GetWallet(spamoor.SelectWalletByPendingTxCount, int(txIdx))
	if wallet == nil {
		return nil, nil, nil, nil, fmt.Errorf("no wallet available")
	}

	client := s.walletPool.GetClient(
		spamoor.WithClientSelectionMode(spamoor.SelectClientByIndex, int(txIdx)),
		spamoor.WithClientGroup(s.options.ClientGroup),
	)
	if client == nil {
		return nil, nil, nil, wallet, fmt.Errorf("no client available")
	}

	feeCap, tipCap, err := s.walletPool.GetTxPool().GetSuggestedFees(client, s.options.BaseFee, s.options.TipFee)
	if err != nil {
		return nil, nil, client, wallet, err
	}

	txData, err := txbuilder.DynFeeTx(&txbuilder.TxMetadata{
		GasFeeCap: uint256.MustFromBig(feeCap),
		GasTipCap: uint256.MustFromBig(tipCap),
		Gas:       s.options.GasLimit,
		To:        nil, // Contract creation
		Value:     uint256.NewInt(0),
		Data:      fuzzedBytecode,
	})
	if err != nil {
		return nil, nil, client, wallet, err
	}

	tx, err := wallet.BuildDynamicFeeTx(txData)

	if err != nil {
		return nil, nil, client, wallet, err
	}

	receiptChan := make(scenario.ReceiptChan, 1)

	err = s.walletPool.GetTxPool().SendTransaction(ctx, wallet, tx, &spamoor.SendTransactionOptions{
		Client:      client,
		ClientGroup: s.options.ClientGroup,
		Rebroadcast: s.options.Rebroadcast > 0,
		OnComplete: func(tx *types.Transaction, receipt *types.Receipt, err error) {
			receiptChan <- receipt
		},
	})
	if err != nil {
		return nil, tx, client, wallet, err
	}

	return receiptChan, tx, client, wallet, nil
}

func (s *Scenario) generateFuzzedBytecode(txIdx uint64) []byte {
	// Apply txID offset for fast-forwarding to specific transaction
	effectiveTxID := txIdx + s.options.TxIdOffset

	// Generate random seed if none provided
	seed := s.options.PayloadSeed
	if seed == "" {
		// Generate a random 32-byte hex seed
		randomBytes := make([]byte, 32)
		rand.Read(randomBytes)
		seed = hex.EncodeToString(randomBytes)
		s.logger.Debugf("Generated random seed: %s", seed)
	}

	// Create deterministic generator for this transaction with seed configuration
	generator := NewOpcodeGenerator(effectiveTxID, seed, int(s.options.MaxCodeSize), s.options.GasLimit)

	// Generate sophisticated stack-aware bytecode
	return generator.Generate()
}

func (s *Scenario) validateSeed(seed string) error {
	// Remove 0x prefix if present
	cleanSeed := strings.TrimPrefix(seed, "0x")

	// Check if it's valid hex
	if _, err := hex.DecodeString(cleanSeed); err != nil {
		return fmt.Errorf("seed must be a valid hex string (with or without 0x prefix): %v", err)
	}

	// Recommend reasonable length for reproducibility
	if len(cleanSeed) > 64 {
		s.logger.Warnf("Seed is longer than 64 hex characters (32 bytes), only first 32 bytes will be used")
	}

	return nil
}
