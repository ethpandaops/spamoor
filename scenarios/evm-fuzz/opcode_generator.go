package evmfuzz

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"sort"
	"strings"
)

// StackItem represents an item on the EVM stack
type StackItem struct {
	Value []byte // 32-byte value
	Known bool   // Whether the value is known/deterministic
}

// DeterministicRNG provides deterministic randomness based on transaction ID
type DeterministicRNG struct {
	state   uint64
	counter uint64
}

// parseHexSeed parses a hex string seed, supporting 0x prefix
func parseHexSeed(seed string) ([]byte, error) {
	// Remove 0x prefix if present
	seed = strings.TrimPrefix(seed, "0x")

	// Ensure even length for proper hex decoding
	if len(seed)%2 == 1 {
		seed = "0" + seed
	}

	return hex.DecodeString(seed)
}

// NewDeterministicRNGWithSeed creates a new deterministic RNG with custom base seed
func NewDeterministicRNGWithSeed(txID uint64, baseSeed string) *DeterministicRNG {
	h := sha256.New()

	// If custom seed provided, use it; otherwise use a fixed fallback
	if baseSeed != "" {
		// Expect hex seed, decode it
		seedBytes, err := parseHexSeed(baseSeed)
		if err != nil {
			// Fallback to seed as bytes if not valid hex
			h.Write([]byte(baseSeed))
		} else {
			h.Write(seedBytes)
		}
	} else {
		// Use fixed fallback for deterministic behavior when no seed provided
		binary.Write(h, binary.LittleEndian, uint64(42))
	}

	// Hash seed+txID for better randomness while maintaining reproducibility
	binary.Write(h, binary.LittleEndian, txID)
	binary.Write(h, binary.LittleEndian, uint64(0x1337DEADBEEF))

	seed := binary.LittleEndian.Uint64(h.Sum(nil)[:8])
	if seed == 0 {
		seed = 1
	}

	return &DeterministicRNG{
		state:   seed,
		counter: 0,
	}
}

func (r *DeterministicRNG) Uint64() uint64 {
	r.counter++
	// Use xorshift64* algorithm for deterministic pseudo-randomness
	r.state ^= r.state >> 12
	r.state ^= r.state << 25
	r.state ^= r.state >> 27
	return r.state * 0x2545F4914F6CDD1D
}

func (r *DeterministicRNG) Intn(n int) int {
	if n <= 0 {
		return 0
	}
	return int(r.Uint64() % uint64(n))
}

func (r *DeterministicRNG) Float64() float64 {
	return float64(r.Uint64()) / float64(^uint64(0))
}

func (r *DeterministicRNG) Bytes(n int) []byte {
	result := make([]byte, n)
	for i := 0; i < n; i += 8 {
		val := r.Uint64()
		for j := 0; j < 8 && i+j < n; j++ {
			result[i+j] = byte(val >> (j * 8))
		}
	}
	return result
}

// encodeSingle encodes an n value (17-235) for DUPN/SWAPN opcodes
func encodeSingle(n int) int {
	if n < 17 || n > 235 {
		return -1 // Invalid
	}
	if n <= 107 {
		return n - 17
	}
	return n + 20
}

// encodePair encodes (n, m) values for EXCHANGE opcode
// Requires 1 <= n <= 13, n < m <= 29, and n+m <= 30
func encodePair(n, m int) int {
	if n < 1 || n > 13 || m <= n || m > 29 || n+m > 30 {
		return -1 // Invalid
	}
	var q, r int
	if m <= 16 {
		q = n - 1
		r = m - 1
	} else {
		q = 29 - m
		r = n - 1
	}
	k := 16*q + r
	if k <= 79 {
		return k
	}
	return k + 48
}

// OpcodeGenerator generates valid EVM bytecode sequences with stack tracking
type OpcodeGenerator struct {
	rng                  *DeterministicRNG
	transformer          *InputTransformer // For generating edge case inputs
	stackSize            int               // Current stack size during generation
	bytecode             []byte            // Generated bytecode
	jumpTargets          []int             // Valid JUMPDEST positions (PC values)
	jumpPlaceholders     []int             // Positions in bytecode where we need to fix jump targets
	maxGas               uint64            // Maximum gas limit
	currentGas           uint64            // Current gas usage
	maxSize              int               // Maximum bytecode size
	opcodeCount          int               // Current opcode count (PC-based instruction count)
	maxOpcodeCount       int               // Maximum allowed opcodes (derived from maxSize with 10x limit)
	opcodeInfos          map[uint16]*OpcodeInfo
	validOpcodes         []*OpcodeInfo
	invalidOpcodes       []byte
	stackBuildingOpcodes []*OpcodeInfo // Cached: opcodes with StackInput=0, StackOutput=1
	txID                 uint64        // Transaction ID for tracking
	baseSeed             string        // Base seed for reproducibility
	fuzzMode             string        // Fuzzing mode: "all", "opcodes", "precompiles"
}

// initializeOpcodes sets up the opcode definitions with sanitization
func (g *OpcodeGenerator) initializeOpcodes() {
	// Start with base opcode definitions from opcodes.go
	opcodes := getBaseOpcodeDefinitions()

	// Add DUP1-DUP16 and SWAP1-SWAP16 from opcodes.go
	opcodes = append(opcodes, getDupOpcodeDefinitions()...)
	opcodes = append(opcodes, getSwapOpcodeDefinitions()...)

	// Add generator-specific opcodes that need generator reference
	generatorOpcodes := []*OpcodeInfo{
		// JUMP and JUMPI need generator for jump target tracking
		{"JUMP", 0x56, 0, 0, 8, g.generateJump, 1.0},
		{"JUMPI", 0x57, 1, 0, 10, g.generateJumpi, 1.0},

		// CREATE and CREATE2 need generator for enhanced deployment
		{"CREATE", 0xf0, 3, 1, 32000, g.createTemplate, 1.8},
		{"CREATE2", 0xf5, 4, 1, 32000, g.create2Template, 1.8},

		// Precompile calls (treated as special opcodes)
		// Specialized handlers generate proper calldata and push results to stack
		// Using 0x100+ range to avoid collision with real EVM opcodes
		{"ECRECOVER", 0x101, 0, 1, 3000, g.generateEcrecoverCall, 2.5},
		{"SHA256", 0x102, 0, 1, 60, g.generateSha256Call, 2.5},
		{"RIPEMD160", 0x103, 0, 1, 600, g.generateRipemd160Call, 2.0},
		{"IDENTITY", 0x104, 0, 1, 15, g.generateIdentityCall, 2.0},
		{"MODEXP", 0x105, 0, 1, 200, g.generateModexpCall, 2.8},
		{"ECADD", 0x106, 0, 2, 500, g.generateBN256EcAddCall, 2.8},
		{"ECMUL", 0x107, 0, 2, 40000, g.generateBN256EcMulCall, 2.8},
		{"ECPAIRING", 0x108, 0, 1, 100000, g.generateBN256PairingCall, 2.8},
		{"BLAKE2F", 0x109, 0, 2, 1, g.generateBlake2fCall, 2.5},
		{"POINTEVAL", 0x10a, 0, 1, 50000, g.generateKZGPointEvalCall, 2.5},

		// BLS12-381 precompiles (Prague fork)
		{"BLS12_G1ADD", 0x10b, 0, 4, 375, g.generateBLS12G1AddCall, 2.5},
		{"BLS12_G1MSM", 0x10c, 0, 4, 30000, g.generateBLS12G1MSMCall, 2.2},
		{"BLS12_G2ADD", 0x10d, 0, 8, 600, g.generateBLS12G2AddCall, 2.5},
		{"BLS12_G2MSM", 0x10e, 0, 8, 150000, g.generateBLS12G2MSMCall, 2.2},
		{"BLS12_PAIRING_CHECK", 0x10f, 0, 1, 37700, g.generateBLS12PairingCall, 2.8},
		{"BLS12_MAP_FP_TO_G1", 0x110, 0, 4, 5500, g.generateBLS12MapFpToG1Call, 2.2},
		{"BLS12_MAP_FP2_TO_G2", 0x111, 0, 8, 23800, g.generateBLS12MapFp2G2Call, 2.2},
	}
	opcodes = append(opcodes, generatorOpcodes...)

	// Add PUSH1-PUSH32 opcodes (need generator for random data generation)
	for i := 1; i <= 32; i++ {
		pushOpcode := uint16(0x5f + i)
		pushSize := i
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("PUSH%d", i),
			Opcode:      pushOpcode,
			StackInput:  0,
			StackOutput: 1,
			GasCost:     3,
			Template:    g.makePushTemplate(pushOpcode, pushSize),
			Probability: 1.0,
		})
	}

	// Add DUPN, SWAPN, EXCHANGE opcodes (EOF/Fusaka opcodes)
	// These have 1-byte immediates and handle stack management in their templates
	// StackInput/StackOutput are set to 0 because the templates manage stack directly
	opcodes = append(opcodes, &OpcodeInfo{
		Name:        "DUPN",
		Opcode:      0xe6,
		StackInput:  17, // Minimum required (n ranges 17-235)
		StackOutput: 18, // n+1 output after duplicating
		GasCost:     3,
		Template:    g.generateDUPN,
		Probability: 1.5,
	})

	opcodes = append(opcodes, &OpcodeInfo{
		Name:        "SWAPN",
		Opcode:      0xe7,
		StackInput:  18, // Minimum required (n+1 where n ranges 17-235)
		StackOutput: 18, // Stack size unchanged
		GasCost:     3,
		Template:    g.generateSWAPN,
		Probability: 1.5,
	})

	opcodes = append(opcodes, &OpcodeInfo{
		Name:        "EXCHANGE",
		Opcode:      0xe8,
		StackInput:  3, // Minimum required (m+1 where smallest valid m is 2)
		StackOutput: 3, // Stack size unchanged
		GasCost:     3,
		Template:    g.generateEXCHANGE,
		Probability: 1.5,
	})

	// Store in map for quick lookup
	for _, op := range opcodes {
		g.opcodeInfos[op.Opcode] = op
	}
}

// NewOpcodeGenerator creates a new opcode generator with optional custom seed
func NewOpcodeGenerator(txID uint64, baseSeed string, maxSize int, maxGas uint64) *OpcodeGenerator {
	rng := NewDeterministicRNGWithSeed(txID, baseSeed)
	g := &OpcodeGenerator{
		rng:              rng,
		transformer:      NewInputTransformer(rng),
		stackSize:        0,
		bytecode:         make([]byte, 0, maxSize),
		jumpTargets:      make([]int, 0),
		jumpPlaceholders: make([]int, 0),
		maxGas:           maxGas,
		currentGas:       0,
		maxSize:          maxSize,
		opcodeCount:      0,
		maxOpcodeCount:   maxSize * 10, // Allow up to 10x the PC size in actual opcodes
		opcodeInfos:      make(map[uint16]*OpcodeInfo),
		txID:             txID,
		baseSeed:         baseSeed,
		fuzzMode:         "all", // Default mode
	}

	g.initializeOpcodes()
	g.buildValidOpcodeList()
	g.buildInvalidOpcodeList()
	g.buildStackBuildingOpcodeList()

	return g
}

// SetFuzzMode sets the fuzzing mode for the generator
func (g *OpcodeGenerator) SetFuzzMode(mode string) {
	g.fuzzMode = mode
	g.buildValidOpcodeList()   // Rebuild the valid opcodes list based on mode
	g.buildInvalidOpcodeList() // Rebuild the invalid opcodes list
}

// buildValidOpcodeList creates a list of valid opcodes for random selection
func (g *OpcodeGenerator) buildValidOpcodeList() {
	g.validOpcodes = g.validOpcodes[:0] // Clear existing list

	for _, op := range g.opcodeInfos {
		// Filter based on fuzz mode
		switch g.fuzzMode {
		case "opcodes":
			// Only include regular EVM opcodes (exclude precompiles 0x01-0x12)
			if !g.isPrecompileOpcode(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		case "precompiles":
			// Only include precompiles - they generate their own complete bytecode internally
			if g.isPrecompileOpcode(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		default: // "all" or any other value
			// Include all opcodes
			g.validOpcodes = append(g.validOpcodes, op)
		}
	}

	// Sort by opcode value to ensure deterministic iteration order
	// (map iteration in Go is non-deterministic)
	sort.Slice(g.validOpcodes, func(i, j int) bool {
		return g.validOpcodes[i].Opcode < g.validOpcodes[j].Opcode
	})
}

// buildInvalidOpcodeList creates a list of invalid opcodes by finding gaps in valid opcodes
func (g *OpcodeGenerator) buildInvalidOpcodeList() {
	// Create a set of valid opcodes (only regular EVM opcodes, not precompiles)
	validOpcodeSet := make(map[byte]bool)

	for _, op := range g.opcodeInfos {
		// Only consider regular EVM opcodes (0x00-0xFF), not precompiles (≥0x100)
		if op.Opcode <= 0xFF {
			validOpcodeSet[byte(op.Opcode)] = true
		}
	}

	// Find all invalid opcodes in the 0x00-0xFF range
	g.invalidOpcodes = g.invalidOpcodes[:0] // Clear existing list

	for opcode := 0; opcode <= 0xFF; opcode++ {
		if !validOpcodeSet[byte(opcode)] {
			g.invalidOpcodes = append(g.invalidOpcodes, byte(opcode))
		}
	}
}

// GetInvalidOpcodes returns a copy of the invalid opcodes list (for testing/debugging)
func (g *OpcodeGenerator) GetInvalidOpcodes() []byte {
	result := make([]byte, len(g.invalidOpcodes))
	copy(result, g.invalidOpcodes)
	return result
}

// buildStackBuildingOpcodeList creates a cached list of opcodes with StackInput=0, StackOutput=1
// These are used to build up the stack when needed for high-stack-input opcodes
// Dynamically built from opcode definitions based on stack properties
func (g *OpcodeGenerator) buildStackBuildingOpcodeList() {
	g.stackBuildingOpcodes = g.stackBuildingOpcodes[:0]

	for _, op := range g.opcodeInfos {
		// Include opcodes with zero input and one output
		if op.StackInput != 0 || op.StackOutput != 1 {
			continue
		}

		// Exclude precompiles (opcode >= 0x100) - they generate complex bytecode
		if op.Opcode >= 0x100 {
			continue
		}

		// Exclude PUSH1-PUSH32 (0x60-0x7f) - we handle these separately with random data
		if op.Opcode >= 0x60 && op.Opcode <= 0x7f {
			continue
		}

		g.stackBuildingOpcodes = append(g.stackBuildingOpcodes, op)
	}

	// Sort for deterministic iteration
	sort.Slice(g.stackBuildingOpcodes, func(i, j int) bool {
		return g.stackBuildingOpcodes[i].Opcode < g.stackBuildingOpcodes[j].Opcode
	})
}

// addStackItems generates bytecode to add n stack items
// Returns false if unable to add enough items due to size/gas limits
func (g *OpcodeGenerator) addStackItems(n int) bool {
	for i := 0; i < n; i++ {
		// Check if we have enough space for at least a PUSH1 (2 bytes)
		if len(g.bytecode)+2 > g.maxSize-32 || g.opcodeCount+1 > g.maxOpcodeCount-10 {
			return false
		}

		// 70% PUSH with data, 30% zero-input opcode for variety
		if g.rng.Float64() < 0.7 {
			// Generate PUSH with weighted distribution favoring smaller pushes
			pushChoice := g.rng.Float64()
			var pushOpcode byte
			var pushSize int

			if pushChoice < 0.40 {
				// 40% PUSH1
				pushOpcode = 0x60
				pushSize = 1
			} else if pushChoice < 0.60 {
				// 20% PUSH2
				pushOpcode = 0x61
				pushSize = 2
			} else if pushChoice < 0.75 {
				// 15% PUSH3
				pushOpcode = 0x62
				pushSize = 3
			} else if pushChoice < 0.90 {
				// 15% PUSH4-PUSH8
				pushSize = 4 + g.rng.Intn(5) // 4-8
				pushOpcode = byte(0x5f + pushSize)
			} else {
				// 10% PUSH9-PUSH32
				pushSize = 9 + g.rng.Intn(24) // 9-32
				pushOpcode = byte(0x5f + pushSize)
			}

			// Check size limit for the push instruction
			if len(g.bytecode)+1+pushSize > g.maxSize-32 {
				// Fall back to PUSH0 if we can't fit the push data
				if len(g.bytecode)+1 > g.maxSize-32 {
					return false
				}
				g.bytecode = append(g.bytecode, 0x5f) // PUSH0
				g.stackSize++
				g.currentGas += 2
				g.opcodeCount++
				continue
			}

			// Generate push instruction with random data
			pushBytes := make([]byte, 1+pushSize)
			pushBytes[0] = pushOpcode
			data := g.rng.Bytes(pushSize)
			copy(pushBytes[1:], data)

			g.bytecode = append(g.bytecode, pushBytes...)
			g.stackSize++
			g.currentGas += 3
			g.opcodeCount++
		} else {
			// Use a zero-input opcode for variety
			if len(g.stackBuildingOpcodes) == 0 {
				// Fallback to PUSH0
				g.bytecode = append(g.bytecode, 0x5f)
				g.stackSize++
				g.currentGas += 2
				g.opcodeCount++
				continue
			}

			op := g.stackBuildingOpcodes[g.rng.Intn(len(g.stackBuildingOpcodes))]

			// Check gas limit
			if g.currentGas+op.GasCost > g.maxGas {
				// Fall back to PUSH0
				g.bytecode = append(g.bytecode, 0x5f)
				g.stackSize++
				g.currentGas += 2
				g.opcodeCount++
				continue
			}

			sequence := op.Template()
			if len(g.bytecode)+len(sequence) > g.maxSize-32 {
				// Fall back to PUSH0
				g.bytecode = append(g.bytecode, 0x5f)
				g.stackSize++
				g.currentGas += 2
				g.opcodeCount++
				continue
			}

			g.bytecode = append(g.bytecode, sequence...)
			g.stackSize++
			g.currentGas += op.GasCost
			g.opcodeCount++
		}
	}
	return true
}

// removeStackItems generates bytecode to remove n stack items
// Returns false if unable to remove enough items due to size/gas limits
func (g *OpcodeGenerator) removeStackItems(n int) bool {
	for n > 0 {
		// Check limits
		if len(g.bytecode)+1 > g.maxSize-32 || g.opcodeCount+1 > g.maxOpcodeCount-10 {
			return false
		}

		// If we have at least 2 items, we can use binary ops (consume 2, produce 1 = net -1)
		if n >= 1 && g.stackSize >= 2 && g.rng.Float64() < 0.3 {
			// 30% chance to use binary op when we have enough stack items
			// Binary ops: ADD (0x01), AND (0x16), OR (0x17), XOR (0x18) - all cost 3 gas
			binaryOps := []byte{0x01, 0x16, 0x17, 0x18}
			op := binaryOps[g.rng.Intn(len(binaryOps))]

			if g.currentGas+3 > g.maxGas {
				// Fall back to POP
				if g.currentGas+2 > g.maxGas {
					return false
				}
				g.bytecode = append(g.bytecode, 0x50) // POP
				g.stackSize--
				g.currentGas += 2
				g.opcodeCount++
				n--
				continue
			}

			g.bytecode = append(g.bytecode, op)
			g.stackSize -= 2 // Consume 2
			g.stackSize++    // Produce 1
			g.currentGas += 3
			g.opcodeCount++
			n-- // Net effect: removed 1 item
		} else {
			// Use POP (consumes 1, produces 0)
			if g.currentGas+2 > g.maxGas {
				return false
			}

			g.bytecode = append(g.bytecode, 0x50) // POP
			g.stackSize--
			g.currentGas += 2
			g.opcodeCount++
			n--
		}
	}
	return true
}

// isPrecompileOpcode checks if an opcode represents a precompile call
func (g *OpcodeGenerator) isPrecompileOpcode(opcode uint16) bool {
	// Precompile opcodes are ≥0x100 to avoid collision with real EVM opcodes
	return opcode >= 0x100 && opcode <= 0x111 // 0x100-0x111 for precompiles 1-18
}

// countOpcodesInBytecode counts the number of opcodes in a bytecode sequence
// This properly handles PUSH opcodes which consume data bytes
func (g *OpcodeGenerator) countOpcodesInBytecode(bytecode []byte) int {
	count := 0
	pc := 0

	for pc < len(bytecode) {
		opcode := bytecode[pc]
		count++

		// Handle PUSH opcodes which consume additional bytes
		if opcode >= 0x60 && opcode <= 0x7f { // PUSH1-PUSH32
			pushSize := int(opcode - 0x5f) // PUSH1=1, PUSH2=2, ..., PUSH32=32
			pc += pushSize + 1             // Skip opcode + push data
		} else if opcode == 0x5f { // PUSH0
			pc++ // Just the opcode, no data
		} else {
			pc++ // Regular opcode
		}
	}

	return count
}

func (g *OpcodeGenerator) createTemplate() []byte  { return g.generateCreate(false) }
func (g *OpcodeGenerator) create2Template() []byte { return g.generateCreate(true) }

// generateDUPN generates DUPN opcode with immediate byte
// DUPN duplicates the n'th stack item (n from 17-235)
// Has 10% chance to generate invalid immediate for testing stack underflow
// Note: Stack changes are handled by updateStackState, not here
func (g *OpcodeGenerator) generateDUPN() []byte {
	// 10% chance to generate invalid immediate (stack underflow test)
	if g.rng.Float64() < 0.1 {
		return g.generateInvalidDUPN()
	}

	// Valid case: choose n based on current stack size
	maxN := g.stackSize
	if maxN < 17 {
		// Not enough stack items, generate with minimum valid n but will cause underflow
		return g.generateInvalidDUPN()
	}
	maxN = min(maxN, 235)

	// Pick n between 17 and min(stackSize, 235)
	n := 17 + g.rng.Intn(maxN-17+1)
	imm := encodeSingle(n)
	imm = max(imm, 0) // Fallback to valid immediate if negative

	return []byte{0xe6, byte(imm)}
}

// generateInvalidDUPN generates DUPN with invalid immediate for testing
func (g *OpcodeGenerator) generateInvalidDUPN() []byte {
	choice := g.rng.Float64()
	var imm int

	if choice < 0.4 {
		// Invalid immediate in forbidden range (91-127)
		imm = 91 + g.rng.Intn(37) // 91-127
	} else if choice < 0.7 {
		// Valid immediate but n > stack size (underflow)
		n := g.stackSize + 1 + g.rng.Intn(50)
		n = max(n, 17)
		n = min(n, 235)
		imm = encodeSingle(n)
		imm = max(imm, 0)
	} else {
		// Random immediate in valid encoding range
		imm = g.rng.Intn(256)
	}

	return []byte{0xe6, byte(imm)}
}

// generateSWAPN generates SWAPN opcode with immediate byte
// SWAPN swaps the n+1'th stack item with the top (n from 17-235)
// Has 10% chance to generate invalid immediate for testing stack underflow
// Note: Stack changes are handled by updateStackState, not here
func (g *OpcodeGenerator) generateSWAPN() []byte {
	// 10% chance to generate invalid immediate (stack underflow test)
	if g.rng.Float64() < 0.1 {
		return g.generateInvalidSWAPN()
	}

	// Valid case: need n+1 items on stack
	maxN := g.stackSize - 1
	if maxN < 17 {
		// Not enough stack items, generate invalid case
		return g.generateInvalidSWAPN()
	}
	maxN = min(maxN, 235)

	// Pick n between 17 and min(stackSize-1, 235)
	n := 17 + g.rng.Intn(maxN-17+1)
	imm := encodeSingle(n)
	imm = max(imm, 0) // Fallback

	// SWAPN doesn't change stack size (just swaps)
	return []byte{0xe7, byte(imm)}
}

// generateInvalidSWAPN generates SWAPN with invalid immediate for testing
func (g *OpcodeGenerator) generateInvalidSWAPN() []byte {
	choice := g.rng.Float64()
	var imm int

	if choice < 0.4 {
		// Invalid immediate in forbidden range (91-127)
		imm = 91 + g.rng.Intn(37) // 91-127
	} else if choice < 0.7 {
		// Valid immediate but n+1 > stack size (underflow)
		n := g.stackSize + g.rng.Intn(50)
		n = max(n, 17)
		n = min(n, 235)
		imm = encodeSingle(n)
		imm = max(imm, 0)
	} else {
		// Random immediate
		imm = g.rng.Intn(256)
	}

	return []byte{0xe7, byte(imm)}
}

// generateEXCHANGE generates EXCHANGE opcode with immediate byte
// EXCHANGE swaps stack[top-n] with stack[top-m] where 1 <= n < m <= 29
// Has 10% chance to generate invalid immediate for testing stack underflow
// Note: Stack changes are handled by updateStackState, not here
func (g *OpcodeGenerator) generateEXCHANGE() []byte {
	// 10% chance to generate invalid immediate (stack underflow test)
	if g.rng.Float64() < 0.1 {
		return g.generateInvalidEXCHANGE()
	}

	// Valid case: need m+1 items on stack where m is the larger index
	// Valid pairs: 1 <= n < m <= 29, n+m <= 30
	// m+1 is the minimum required stack depth

	// Find valid (n, m) pairs that fit current stack
	type pair struct{ n, m int }
	var validPairs []pair

	for n := 1; n <= 13; n++ {
		for m := n + 1; m <= 29 && n+m <= 30; m++ {
			if m+1 <= g.stackSize {
				validPairs = append(validPairs, pair{n, m})
			}
		}
	}

	if len(validPairs) == 0 {
		// Not enough stack items for any valid EXCHANGE
		return g.generateInvalidEXCHANGE()
	}

	// Pick a random valid pair
	p := validPairs[g.rng.Intn(len(validPairs))]
	imm := encodePair(p.n, p.m)
	imm = max(imm, 0) // Fallback

	// EXCHANGE doesn't change stack size (just swaps)
	return []byte{0xe8, byte(imm)}
}

// generateInvalidEXCHANGE generates EXCHANGE with invalid immediate for testing
func (g *OpcodeGenerator) generateInvalidEXCHANGE() []byte {
	choice := g.rng.Float64()
	var imm int

	if choice < 0.4 {
		// Invalid immediate in forbidden range (80-127)
		imm = 80 + g.rng.Intn(48) // 80-127
	} else if choice < 0.7 {
		// Valid immediate but m+1 > stack size (underflow)
		// Generate a pair that exceeds current stack
		n := 1 + g.rng.Intn(13) // 1-13
		m := n + 1 + g.rng.Intn(max(29-n-1, 1))
		m = min(m, 30-n) // Ensure n+m <= 30
		m = max(m, n+1)  // Ensure m > n
		m = min(m, 29)   // Ensure m <= 29
		imm = encodePair(n, m)
		if imm < 0 {
			// Fallback to random valid-looking immediate
			imm = g.rng.Intn(80) // Valid range 0-79
		}
	} else {
		// Random immediate
		imm = g.rng.Intn(256)
	}

	return []byte{0xe8, byte(imm)}
}

// makePushTemplate creates a template function for PUSH opcodes
func (g *OpcodeGenerator) makePushTemplate(opcode uint16, size int) func() []byte {
	return func() []byte {
		result := make([]byte, 1+size)
		result[0] = byte(opcode) // Cast to byte since PUSH opcodes are always ≤ 0xff

		// Generate random data for PUSH
		data := g.rng.Bytes(size)
		copy(result[1:], data)

		return result
	}
}

// generateJump creates a JUMP instruction with a placeholder target
func (g *OpcodeGenerator) generateJump() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMP (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x56}
}

// generateJumpi creates a JUMPI instruction with a placeholder target
func (g *OpcodeGenerator) generateJumpi() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMPI (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x57}
}

// generateCreate creates enhanced CREATE/CREATE2 with 50% chance of full deployment + call
func (g *OpcodeGenerator) generateCreate(isCreate2 bool) []byte {
	// 60% chance for enhanced deployment with subsequent call
	if g.rng.Float64() < 0.6 {
		return g.generateCreateWithCall(isCreate2)
	}

	// 40% chance for simple CREATE/CREATE2 (existing behavior)
	if isCreate2 {
		return []byte{0xf5} // CREATE2
	}
	return []byte{0xf0} // CREATE
}

// generateCreateWithCall implements the full deployment + call pattern
func (g *OpcodeGenerator) generateCreateWithCall(isCreate2 bool) []byte {
	var bytecode []byte

	// Step 1: Load current bytecode into memory at offset 0
	// CODESIZE - get size of current contract code
	bytecode = append(bytecode, 0x38) // CODESIZE

	// DUP1 - duplicate size for CODECOPY
	bytecode = append(bytecode, 0x80) // DUP1

	// PUSH0 - source offset in code
	bytecode = append(bytecode, 0x5f) // PUSH0

	// PUSH0 - destination offset in memory
	bytecode = append(bytecode, 0x5f) // PUSH0

	// CODECOPY - copy current code to memory[0:]
	bytecode = append(bytecode, 0x39) // CODECOPY

	// Step 2: Overwrite first 32 bytes with jump bypass pattern
	// We need to create: PUSH4 0x00000000 JUMP PUSH26 <remaining_bytes>
	// Calculate the jump target first (it will be at the end of this sequence)

	// Create the bypass pattern (32 bytes total)
	bypassPattern := make([]byte, 32)
	bypassPattern[0] = 0x63 // PUSH4
	// 1-4 are 0x00000000
	bypassPattern[5] = 0x56 // JUMP
	bypassPattern[6] = 0x79 // PUSH26
	// bytes 7-32 are PUSH26 data (can be anything, we'll use random)
	copy(bypassPattern[7:], g.rng.Bytes(25))

	// Store the bypass pattern in memory starting at offset 0
	// PUSH32 <byte> - push the byte value
	bytecode = append(bytecode, 0x7f)
	jumpAddrPos := len(bytecode) + 1 // position of the jump address
	bytecode = append(bytecode, bypassPattern...)
	// PUSH0 - push memory offset
	bytecode = append(bytecode, 0x5f)
	// MSTORE - store word in memory
	bytecode = append(bytecode, 0x52)

	// Step 3: Prepare CREATE/CREATE2 arguments
	// For CREATE: value, offset, size
	// For CREATE2: value, offset, size, salt

	// push salt
	if isCreate2 {
		// PUSH4 <random_salt> - salt for CREATE2
		salt := g.rng.Bytes(4)
		bytecode = append(bytecode, 0x63)
		bytecode = append(bytecode, salt...)

		// SWAP1 - swap salt with size
		bytecode = append(bytecode, 0x90)
	}

	// PUSH0 - offset
	bytecode = append(bytecode, 0x5f)

	// Push value - 30% chance for random value, 70% chance for 0
	if g.rng.Float64() < 0.3 {
		// Random value between 0xa000-0xffff
		randomValue := 0xa000 + g.rng.Intn(0x6000)                                 // 0xa000 + [0, 0x5fff] = [0xa000, 0xffff]
		bytecode = append(bytecode, 0x61, byte(randomValue>>8), byte(randomValue)) // PUSH2
	} else {
		// PUSH0 - value (0 ETH)
		bytecode = append(bytecode, 0x5f)
	}

	if isCreate2 {
		// CREATE2
		bytecode = append(bytecode, 0xf5)
	} else {
		// CREATE
		bytecode = append(bytecode, 0xf0)
	}

	// Step 4: Call into the newly created contract
	// Determine call type (40% call, 40% delegatecall, 10% staticcall, 10% callcode)
	callChoice := g.rng.Float64()

	if callChoice < 0.4 { // 40% CALL
		// Prepare CALL arguments: gas, address, value, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - value
		bytecode = append(bytecode, 0x85) // DUP6 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf1) // CALL
	} else if callChoice < 0.8 { // 40% DELEGATECALL
		// Prepare DELEGATECALL arguments: gas, address, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x84) // DUP5 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf4) // DELEGATECALL
	} else if callChoice < 0.9 { // 10% STATICCALL
		// Prepare STATICCALL arguments: gas, address, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x84) // DUP5 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xfa) // STATICCALL
	} else { // 10% CALLCODE
		// Prepare CALLCODE arguments: gas, address, value, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - value
		bytecode = append(bytecode, 0x85) // DUP6 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf2) // CALLCODE
	}

	// Step 5: Add JUMPDEST for the inner call entrypoint
	// Record the position where we need to place the JUMPDEST
	jumpdestPos := len(g.bytecode) + len(bytecode)
	g.jumpTargets = append(g.jumpTargets, jumpdestPos)

	// update jump address
	bytecode[jumpAddrPos+1] = byte(jumpdestPos >> 16)
	bytecode[jumpAddrPos+2] = byte(jumpdestPos >> 8)
	bytecode[jumpAddrPos+3] = byte(jumpdestPos)

	// Add the JUMPDEST
	bytecode = append(bytecode, 0x5b) // JUMPDEST
	g.stackSize = 0                   // clear stack to avoid underflow in inner call

	return bytecode
}

// pushSeedAndTxID adds initial stack values for seed and txID tracking
func (g *OpcodeGenerator) pushSeedAndTxID() {
	// Use exact seed bytes (32-byte value, pad or truncate as needed)
	seedBytes := make([]byte, 32)
	if g.baseSeed != "" {
		// Parse hex seed and use exact bytes
		if parsedSeed, err := parseHexSeed(g.baseSeed); err == nil {
			// If seed is longer than 32 bytes, take first 32
			if len(parsedSeed) >= 32 {
				copy(seedBytes, parsedSeed[:32])
			} else {
				// If seed is shorter, copy to the end (big-endian style)
				copy(seedBytes[32-len(parsedSeed):], parsedSeed)
			}
		} else {
			// Fallback: convert string to bytes (for non-hex seeds)
			seedStr := []byte(g.baseSeed)
			if len(seedStr) >= 32 {
				copy(seedBytes, seedStr[:32])
			} else {
				copy(seedBytes[32-len(seedStr):], seedStr)
			}
		}
	}
	// If no seed provided, seedBytes remains all zeros

	// Push seed first (will be deeper on stack)
	seedPush := make([]byte, 33)
	seedPush[0] = 0x7f // PUSH32
	copy(seedPush[1:], seedBytes)
	g.bytecode = append(g.bytecode, seedPush...)
	g.stackSize += 1
	g.currentGas += 3

	// Push txID (will be on top of stack)
	txIDBytes := make([]byte, 32)
	binary.BigEndian.PutUint64(txIDBytes[24:], g.txID) // Place in low bytes
	txIDPush := make([]byte, 33)
	txIDPush[0] = 0x7f // PUSH32
	copy(txIDPush[1:], txIDBytes)
	g.bytecode = append(g.bytecode, txIDPush...)
	g.stackSize += 1
	g.currentGas += 3
}

// Generate creates a valid bytecode sequence
func (g *OpcodeGenerator) Generate() []byte {
	g.bytecode = g.bytecode[:0]
	g.stackSize = 0
	g.jumpTargets = g.jumpTargets[:0]
	g.jumpPlaceholders = g.jumpPlaceholders[:0]
	g.currentGas = 0
	g.opcodeCount = 0

	// Push seed and txID as initial stack values for tracking
	g.pushSeedAndTxID()
	// Count the initial PUSH operations (2 PUSH32 opcodes)
	g.opcodeCount += 2

	// Generate bytecode
	for len(g.bytecode) < g.maxSize-32 && g.currentGas < g.maxGas-1000 && g.opcodeCount < g.maxOpcodeCount-10 {
		// Randomly place JUMPDESTs (20% chance when we have few targets)
		if len(g.jumpTargets) < 10 && g.rng.Float64() < 0.2 {
			pc := len(g.bytecode)
			g.bytecode = append(g.bytecode, 0x5b) // JUMPDEST
			g.jumpTargets = append(g.jumpTargets, pc)
			g.currentGas += 1
			g.opcodeCount += 1 // Count the JUMPDEST opcode
			continue
		}

		if !g.generateNextInstruction() {
			break
		}
	}

	// Ensure we end with a safe terminating instruction
	if len(g.bytecode) < g.maxSize-1 && g.opcodeCount < g.maxOpcodeCount {
		g.bytecode = append(g.bytecode, 0x00) // STOP
		g.opcodeCount += 1                    // Count the STOP opcode
	}

	// Fix up jump targets
	g.fixJumpTargets()

	return g.bytecode
}

// fixJumpTargets replaces placeholder jump targets with actual JUMPDEST positions
func (g *OpcodeGenerator) fixJumpTargets() {
	for _, placeholderPos := range g.jumpPlaceholders {
		var target int

		// 10% chance of invalid jump
		if g.rng.Float64() < 0.1 {
			// Generate invalid target
			targetType := g.rng.Intn(3)
			switch targetType {
			case 0: // Jump beyond bytecode
				target = len(g.bytecode) + g.rng.Intn(1000)
			case 1: // Jump to random position (likely not JUMPDEST)
				target = g.rng.Intn(len(g.bytecode))
			case 2: // Jump to data byte (middle of PUSH)
				// Try to find a PUSH instruction and jump into its data
				for i := 0; i < len(g.bytecode)-2; i++ {
					if g.bytecode[i] >= 0x60 && g.bytecode[i] <= 0x7f { // PUSH1-PUSH32
						pushSize := int(g.bytecode[i] - 0x5f)
						if i+pushSize < len(g.bytecode) {
							target = i + 1 + g.rng.Intn(pushSize) // Jump into PUSH data
							break
						}
					}
				}
				if target == 0 {
					target = g.rng.Intn(len(g.bytecode))
				}
			}
		} else {
			// 90% valid jump - pick a JUMPDEST
			if len(g.jumpTargets) > 0 {
				target = g.jumpTargets[g.rng.Intn(len(g.jumpTargets))]
			} else {
				// No JUMPDESTs, generate likely invalid target
				target = g.rng.Intn(len(g.bytecode))
			}
		}

		// Write target as big-endian PUSH2 data
		if placeholderPos+1 < len(g.bytecode) {
			g.bytecode[placeholderPos] = byte(target >> 8)
			g.bytecode[placeholderPos+1] = byte(target)
		}
	}
}

// generateNextInstruction generates the next valid instruction
func (g *OpcodeGenerator) generateNextInstruction() bool {
	// Decide what type of instruction to generate
	choice := g.rng.Float64()

	if choice < 0.001 { // 0.1% chance of invalid opcode
		invalidOp := g.invalidOpcodes[g.rng.Intn(len(g.invalidOpcodes))]
		g.bytecode = append(g.bytecode, invalidOp)
		g.currentGas += 3  // Assume some gas cost
		g.opcodeCount += 1 // Count the invalid opcode
		return true
	}

	if choice < 0.004 { // 0.3% chance of random byte
		g.bytecode = append(g.bytecode, byte(g.rng.Intn(256)))
		g.currentGas += 3
		g.opcodeCount += 1 // Count the random byte as an opcode
		return true
	}

	// 99.6% chance of valid opcode
	return g.generateValidInstruction()
}

// generateValidInstruction generates a valid instruction using stack-fulfilling opcode selection
// This approach selects opcodes based on GAS only, then fulfills stack requirements with preamble
func (g *OpcodeGenerator) generateValidInstruction() bool {
	// Step 1: Select candidates based on GAS only (not stack)
	var candidates []*OpcodeInfo

	for _, op := range g.validOpcodes {
		if g.currentGas+op.GasCost <= g.maxGas {
			candidates = append(candidates, op)
		}
	}

	if len(candidates) == 0 {
		return false
	}

	// Step 2: Weighted selection (without stack bias)
	op := g.selectWeightedOpcode(candidates)

	// Step 3: Fulfill stack requirements
	stackNeeded := op.StackInput - g.stackSize
	if stackNeeded > 0 {
		if !g.addStackItems(stackNeeded) {
			return g.generateValidInstructionFallback()
		}
	}

	// Step 4: Handle stack overflow
	resultStack := g.stackSize - op.StackInput + op.StackOutput
	if resultStack > 1024 {
		toRemove := resultStack - 1024
		if !g.removeStackItems(toRemove) {
			return g.generateValidInstructionFallback()
		}
	}

	// Step 5: Generate the opcode
	sequence := op.Template()
	sequenceOpcodeCount := g.countOpcodesInBytecode(sequence)

	// Check both bytecode size and opcode count limits
	if len(g.bytecode)+len(sequence) > g.maxSize || g.opcodeCount+sequenceOpcodeCount > g.maxOpcodeCount {
		return g.generateValidInstructionFallback()
	}

	g.bytecode = append(g.bytecode, sequence...)
	g.currentGas += op.GasCost
	g.opcodeCount += sequenceOpcodeCount

	// Update stack state
	g.updateStackState(op)

	return true
}

// generateValidInstructionFallback is the fallback for when preamble generation fails
// Uses original filtering logic as a last resort
func (g *OpcodeGenerator) generateValidInstructionFallback() bool {
	// Filter opcodes that we can actually execute given current stack state
	var candidates []*OpcodeInfo

	for _, op := range g.validOpcodes {
		if g.stackSize >= op.StackInput &&
			g.stackSize-op.StackInput+op.StackOutput <= 1024 &&
			g.currentGas+op.GasCost <= g.maxGas {
			candidates = append(candidates, op)
		}
	}

	if len(candidates) == 0 {
		// No valid candidates, try to add some stack items
		if g.stackSize < 1020 {
			pushData := byte(g.rng.Intn(256))
			g.bytecode = append(g.bytecode, 0x60, pushData) // PUSH1
			g.stackSize++
			g.currentGas += 3
			g.opcodeCount++
			return true
		}
		return false
	}

	// Select a random candidate from filtered list
	op := candidates[g.rng.Intn(len(candidates))]

	// Generate the instruction
	sequence := op.Template()
	sequenceOpcodeCount := g.countOpcodesInBytecode(sequence)

	if len(g.bytecode)+len(sequence) > g.maxSize || g.opcodeCount+sequenceOpcodeCount > g.maxOpcodeCount {
		return false
	}

	g.bytecode = append(g.bytecode, sequence...)
	g.currentGas += op.GasCost
	g.opcodeCount += sequenceOpcodeCount

	g.updateStackState(op)

	return true
}

// selectWeightedOpcode selects an opcode with weighted probability
// Stack requirements are now handled by addStackItems/removeStackItems, so selection is purely based on weights
func (g *OpcodeGenerator) selectWeightedOpcode(candidates []*OpcodeInfo) *OpcodeInfo {
	// Use weighted selection based on probability field
	totalWeight := 0.0
	for _, op := range candidates {
		totalWeight += op.Probability
	}

	if totalWeight == 0 {
		// Fallback to random selection if no probabilities set
		return candidates[g.rng.Intn(len(candidates))]
	}

	// Select based on weight
	randomValue := g.rng.Float64() * totalWeight
	currentWeight := 0.0

	for _, op := range candidates {
		currentWeight += op.Probability
		if randomValue <= currentWeight {
			return op
		}
	}

	// Fallback to last candidate
	return candidates[len(candidates)-1]
}

// updateStackState updates the virtual stack based on the executed operation
func (g *OpcodeGenerator) updateStackState(op *OpcodeInfo) {
	// Standard stack handling for other opcodes
	// Remove consumed items
	if g.stackSize >= op.StackInput {
		g.stackSize -= op.StackInput
	} else {
		g.stackSize = 0
	}

	// Add produced items
	g.stackSize += op.StackOutput
}
