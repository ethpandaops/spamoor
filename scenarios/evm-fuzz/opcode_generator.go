package evmfuzz

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"strings"
)

// StackItem represents an item on the EVM stack
type StackItem struct {
	Value []byte // 32-byte value
	Known bool   // Whether the value is known/deterministic
}

// DeterministicRNG provides deterministic randomness based on transaction ID
type DeterministicRNG struct {
	state   uint64
	counter uint64
}

// parseHexSeed parses a hex string seed, supporting 0x prefix
func parseHexSeed(seed string) ([]byte, error) {
	// Remove 0x prefix if present
	seed = strings.TrimPrefix(seed, "0x")

	// Ensure even length for proper hex decoding
	if len(seed)%2 == 1 {
		seed = "0" + seed
	}

	return hex.DecodeString(seed)
}

// NewDeterministicRNGWithSeed creates a new deterministic RNG with custom base seed
func NewDeterministicRNGWithSeed(txID uint64, baseSeed string) *DeterministicRNG {
	h := sha256.New()

	// If custom seed provided, use it; otherwise use a fixed fallback
	if baseSeed != "" {
		// Expect hex seed, decode it
		seedBytes, err := parseHexSeed(baseSeed)
		if err != nil {
			// Fallback to seed as bytes if not valid hex
			h.Write([]byte(baseSeed))
		} else {
			h.Write(seedBytes)
		}
	} else {
		// Use fixed fallback for deterministic behavior when no seed provided
		binary.Write(h, binary.LittleEndian, uint64(42))
	}

	// Hash seed+txID for better randomness while maintaining reproducibility
	binary.Write(h, binary.LittleEndian, txID)
	binary.Write(h, binary.LittleEndian, uint64(0x1337DEADBEEF))

	seed := binary.LittleEndian.Uint64(h.Sum(nil)[:8])
	if seed == 0 {
		seed = 1
	}

	return &DeterministicRNG{
		state:   seed,
		counter: 0,
	}
}

func (r *DeterministicRNG) Uint64() uint64 {
	r.counter++
	// Use xorshift64* algorithm for deterministic pseudo-randomness
	r.state ^= r.state >> 12
	r.state ^= r.state << 25
	r.state ^= r.state >> 27
	return r.state * 0x2545F4914F6CDD1D
}

func (r *DeterministicRNG) Intn(n int) int {
	if n <= 0 {
		return 0
	}
	return int(r.Uint64() % uint64(n))
}

func (r *DeterministicRNG) Float64() float64 {
	return float64(r.Uint64()) / float64(^uint64(0))
}

func (r *DeterministicRNG) Bytes(n int) []byte {
	result := make([]byte, n)
	for i := 0; i < n; i += 8 {
		val := r.Uint64()
		for j := 0; j < 8 && i+j < n; j++ {
			result[i+j] = byte(val >> (j * 8))
		}
	}
	return result
}

// OpcodeInfo defines properties of an EVM opcode
type OpcodeInfo struct {
	Name        string
	Opcode      uint16 // uint16 to support precompiles (≥0x100) and regular opcodes (≤0xff)
	StackInput  int    // Number of items consumed from stack
	StackOutput int    // Number of items pushed to stack
	GasCost     uint64
	Template    func(g *OpcodeGenerator) []byte // Function to generate valid sequence
	Probability float64                         // Relative probability weight for selection (1.0 = normal)
}

// OpcodeGenerator generates valid EVM bytecode sequences with stack tracking
type OpcodeGenerator struct {
	rng              *DeterministicRNG
	stack            []StackItem // Current stack state during generation
	bytecode         []byte      // Generated bytecode
	jumpTargets      []int       // Valid JUMPDEST positions (PC values)
	jumpPlaceholders []int       // Positions in bytecode where we need to fix jump targets
	maxGas           uint64      // Maximum gas limit
	currentGas       uint64      // Current gas usage
	maxSize          int         // Maximum bytecode size
	opcodeInfos      map[uint16]*OpcodeInfo
	validOpcodes     []*OpcodeInfo
	invalidOpcodes   []byte
	txID             uint64 // Transaction ID for tracking
	baseSeed         string // Base seed for reproducibility
	fuzzMode         string // Fuzzing mode: "all", "opcodes", "precompiles"
}

// Template functions for opcodes
func simpleOpcode(opcode byte) func(g *OpcodeGenerator) []byte {
	return func(g *OpcodeGenerator) []byte { return []byte{opcode} }
}

func jumpTemplate(g *OpcodeGenerator) []byte     { return g.generateJump() }
func jumpiTemplate(g *OpcodeGenerator) []byte    { return g.generateJumpi() }
func callTemplate(g *OpcodeGenerator) []byte     { return g.generateCallWithZeroValue(0xf1) }
func callcodeTemplate(g *OpcodeGenerator) []byte { return g.generateCallWithZeroValue(0xf2) }

// Generic sanitization wrapper - applies masks to stack positions before executing base template
// masks[i] = mask for stack position i (0 = no sanitization)
func sanitizeInput(baseTemplate func(g *OpcodeGenerator) []byte, masks []uint64) func(g *OpcodeGenerator) []byte {
	return func(g *OpcodeGenerator) []byte {
		var bytecode []byte

		// Apply sanitization to each specified stack position
		for i, mask := range masks {
			if mask == 0 {
				continue // Skip positions that don't need sanitization
			}

			// Generate appropriate PUSH instruction for the mask
			var pushBytes []byte
			if mask <= 0xFF {
				pushBytes = []byte{0x60, byte(mask)} // PUSH1
			} else if mask <= 0xFFFF {
				pushBytes = []byte{0x61, byte(mask >> 8), byte(mask)} // PUSH2
			} else if mask <= 0x2ffff {
				pushBytes = []byte{0x62, byte(mask >> 16), byte(mask >> 8), byte(mask)} // PUSH3
			} else {
				pushBytes = []byte{0x63, byte(mask >> 24), byte(mask >> 16), byte(mask >> 8), byte(mask)} // PUSH4
			}

			if i == 0 {
				// Sanitize stack[0] (top of stack)
				bytecode = append(bytecode, pushBytes...)
				bytecode = append(bytecode, 0x16) // AND
			} else {
				// Sanitize stack[i] - need to use DUP to copy to top, sanitize, then SWAP back
				dupOpcode := byte(0x80 + i)  // DUP(i+1)
				swapOpcode := byte(0x90 + i) // SWAP(i+1)

				bytecode = append(bytecode, dupOpcode)    // DUP(i+1) - copy stack[i] to top
				bytecode = append(bytecode, pushBytes...) // PUSH mask
				bytecode = append(bytecode, 0x16)         // AND (sanitize)
				bytecode = append(bytecode, swapOpcode)   // SWAP(i+1) - put sanitized value back
				bytecode = append(bytecode, 0x50)         // POP (remove original unsanitized value)
			}
		}

		// Execute the base template
		baseBytes := baseTemplate(g)
		bytecode = append(bytecode, baseBytes...)

		return bytecode
	}
}

// initializeOpcodes sets up the opcode definitions with sanitization
func (g *OpcodeGenerator) initializeOpcodes() {
	opcodes := []*OpcodeInfo{
		// Stack operations
		{"STOP", 0x00, 0, 0, 0, simpleOpcode(0x00), 0.1}, // Lower probability - ends execution
		{"ADD", 0x01, 2, 1, 3, simpleOpcode(0x01), 1.0},
		{"MUL", 0x02, 2, 1, 5, simpleOpcode(0x02), 1.0},
		{"SUB", 0x03, 2, 1, 3, simpleOpcode(0x03), 1.0},
		{"DIV", 0x04, 2, 1, 5, simpleOpcode(0x04), 1.0},
		{"SDIV", 0x05, 2, 1, 5, simpleOpcode(0x05), 1.0},
		{"MOD", 0x06, 2, 1, 5, simpleOpcode(0x06), 1.0},
		{"SMOD", 0x07, 2, 1, 5, simpleOpcode(0x07), 1.0},
		{"ADDMOD", 0x08, 3, 1, 8, simpleOpcode(0x08), 1.0},
		{"MULMOD", 0x09, 3, 1, 8, simpleOpcode(0x09), 1.0},
		{"EXP", 0x0a, 2, 1, 10, simpleOpcode(0x0a), 1.0},
		{"SIGNEXTEND", 0x0b, 2, 1, 5, simpleOpcode(0x0b), 1.0},

		// Comparison operations
		{"LT", 0x10, 2, 1, 3, simpleOpcode(0x10), 1.0},
		{"GT", 0x11, 2, 1, 3, simpleOpcode(0x11), 1.0},
		{"SLT", 0x12, 2, 1, 3, simpleOpcode(0x12), 1.0},
		{"SGT", 0x13, 2, 1, 3, simpleOpcode(0x13), 1.0},
		{"EQ", 0x14, 2, 1, 3, simpleOpcode(0x14), 1.0},
		{"ISZERO", 0x15, 1, 1, 3, simpleOpcode(0x15), 1.0},
		{"AND", 0x16, 2, 1, 3, simpleOpcode(0x16), 1.0},
		{"OR", 0x17, 2, 1, 3, simpleOpcode(0x17), 1.0},
		{"XOR", 0x18, 2, 1, 3, simpleOpcode(0x18), 1.0},
		{"NOT", 0x19, 1, 1, 3, simpleOpcode(0x19), 1.0},
		{"BYTE", 0x1a, 2, 1, 3, simpleOpcode(0x1a), 1.0},
		{"SHL", 0x1b, 2, 1, 3, simpleOpcode(0x1b), 1.0},
		{"SHR", 0x1c, 2, 1, 3, simpleOpcode(0x1c), 1.0},
		{"SAR", 0x1d, 2, 1, 3, simpleOpcode(0x1d), 1.0},

		// Crypto operations
		{"KECCAK256", 0x20, 2, 1, 30, sanitizeInput(simpleOpcode(0x20), []uint64{0x2ffff, 0xffff}), 1.5}, // Sanitize offset and length

		// Environmental information
		{"ADDRESS", 0x30, 0, 1, 2, simpleOpcode(0x30), 2.0},
		{"BALANCE", 0x31, 1, 1, 100, simpleOpcode(0x31), 2.2}, // Interesting for fuzzing
		{"ORIGIN", 0x32, 0, 1, 2, simpleOpcode(0x32), 2.0},
		{"CALLER", 0x33, 0, 1, 2, simpleOpcode(0x33), 2.0},
		{"CALLVALUE", 0x34, 0, 1, 2, simpleOpcode(0x34), 2.0},
		{"CALLDATALOAD", 0x35, 1, 1, 3, simpleOpcode(0x35), 2.0},
		{"CALLDATASIZE", 0x36, 0, 1, 2, simpleOpcode(0x36), 2.0},
		{"CALLDATACOPY", 0x37, 3, 0, 3, sanitizeInput(simpleOpcode(0x37), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"CODESIZE", 0x38, 0, 1, 2, simpleOpcode(0x38), 2.0},
		{"CODECOPY", 0x39, 3, 0, 3, sanitizeInput(simpleOpcode(0x39), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"GASPRICE", 0x3a, 0, 1, 2, simpleOpcode(0x3a), 2.0},
		{"EXTCODESIZE", 0x3b, 1, 1, 100, simpleOpcode(0x3b), 2.0},
		{"EXTCODECOPY", 0x3c, 4, 0, 100, sanitizeInput(simpleOpcode(0x3c), []uint64{0, 0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length (not address)
		{"RETURNDATASIZE", 0x3d, 0, 1, 2, simpleOpcode(0x3d), 2.0},
		{"RETURNDATACOPY", 0x3e, 3, 0, 3, sanitizeInput(simpleOpcode(0x3e), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"EXTCODEHASH", 0x3f, 1, 1, 100, simpleOpcode(0x3f), 2.0},

		// Block information
		{"BLOCKHASH", 0x40, 1, 1, 20, simpleOpcode(0x40), 2.0},
		{"COINBASE", 0x41, 0, 1, 2, simpleOpcode(0x41), 2.0},
		{"TIMESTAMP", 0x42, 0, 1, 2, simpleOpcode(0x42), 2.0},
		{"NUMBER", 0x43, 0, 1, 2, simpleOpcode(0x43), 2.0},
		{"DIFFICULTY", 0x44, 0, 1, 2, simpleOpcode(0x44), 2.0},
		{"GASLIMIT", 0x45, 0, 1, 2, simpleOpcode(0x45), 2.0},
		{"CHAINID", 0x46, 0, 1, 2, simpleOpcode(0x46), 2.5},     // New/interesting
		{"SELFBALANCE", 0x47, 0, 1, 5, simpleOpcode(0x47), 2.5}, // New/interesting
		{"BASEFEE", 0x48, 0, 1, 2, simpleOpcode(0x48), 2.5},     // New/interesting
		{"BLOBHASH", 0x49, 1, 1, 3, simpleOpcode(0x49), 2.0},    // Very new/interesting
		{"BLOBBASEFEE", 0x4a, 0, 1, 2, simpleOpcode(0x4a), 2.0}, // Very new/interesting

		// Stack operations with memory/storage sanitization
		{"POP", 0x50, 1, 0, 2, simpleOpcode(0x50), 1.0},
		{"MLOAD", 0x51, 1, 1, 3, sanitizeInput(simpleOpcode(0x51), []uint64{0x2ffff}), 1.0},    // Sanitize offset
		{"MSTORE", 0x52, 2, 0, 3, sanitizeInput(simpleOpcode(0x52), []uint64{0x2ffff}), 1.0},   // Sanitize offset
		{"MSTORE8", 0x53, 2, 0, 3, sanitizeInput(simpleOpcode(0x53), []uint64{0x2ffff}), 1.0},  // Sanitize offset
		{"SLOAD", 0x54, 1, 1, 100, sanitizeInput(simpleOpcode(0x54), []uint64{0x2ffff}), 1.2},  // Sanitize storage key
		{"SSTORE", 0x55, 2, 0, 100, sanitizeInput(simpleOpcode(0x55), []uint64{0x2ffff}), 1.2}, // Sanitize storage key
		{"JUMP", 0x56, 0, 0, 8, jumpTemplate, 1.0},
		{"JUMPI", 0x57, 1, 0, 10, jumpiTemplate, 1.0},
		{"PC", 0x58, 0, 1, 2, simpleOpcode(0x58), 1.0},
		{"MSIZE", 0x59, 0, 1, 2, simpleOpcode(0x59), 1.0},
		{"GAS", 0x5a, 0, 1, 2, simpleOpcode(0x5a), 1.0},
		{"JUMPDEST", 0x5b, 0, 0, 1, simpleOpcode(0x5b), 1.0},
		{"TLOAD", 0x5c, 1, 1, 100, sanitizeInput(simpleOpcode(0x5c), []uint64{0x2ffff}), 2.0},                // Sanitize storage key
		{"TSTORE", 0x5d, 2, 0, 100, sanitizeInput(simpleOpcode(0x5d), []uint64{0x2ffff}), 2.0},               // Sanitize storage key
		{"MCOPY", 0x5e, 3, 0, 3, sanitizeInput(simpleOpcode(0x5e), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, size

		// Push operations (PUSH1-PUSH32)
		{"PUSH0", 0x5f, 0, 1, 2, simpleOpcode(0x5f), 1.0},

		// Log operations - sanitize memory offset
		{"LOG0", 0xa0, 2, 0, 375, sanitizeInput(simpleOpcode(0xa0), []uint64{0x2ffff, 0xffff}), 1.0},  // Sanitize offset
		{"LOG1", 0xa1, 3, 0, 750, sanitizeInput(simpleOpcode(0xa1), []uint64{0x2ffff, 0xffff}), 1.0},  // Sanitize offset
		{"LOG2", 0xa2, 4, 0, 1125, sanitizeInput(simpleOpcode(0xa2), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset
		{"LOG3", 0xa3, 5, 0, 1500, sanitizeInput(simpleOpcode(0xa3), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset
		{"LOG4", 0xa4, 6, 0, 1875, sanitizeInput(simpleOpcode(0xa4), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset

		// Contract operations
		{"CREATE", 0xf0, 3, 1, 32000, sanitizeInput(simpleOpcode(0xf0), []uint64{0, 0x2ffff, 0xffff}), 1.5},                         // Sanitize offset, length (not value)
		{"CALL", 0xf1, 6, 1, 100, sanitizeInput(callTemplate, []uint64{0, 0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3},            // Sanitize memory args, custom value=0
		{"CALLCODE", 0xf2, 6, 1, 100, sanitizeInput(callcodeTemplate, []uint64{0, 0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.0},    // Sanitize memory args, custom value=0
		{"RETURN", 0xf3, 2, 0, 0, sanitizeInput(simpleOpcode(0xf3), []uint64{0x2ffff, 0xffff}), 0.1},                                // Sanitize offset, length - Lower - ends execution
		{"DELEGATECALL", 0xf4, 6, 1, 100, sanitizeInput(simpleOpcode(0xf4), []uint64{0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3}, // Sanitize argsOffset, argsSize, retOffset, retSize
		{"CREATE2", 0xf5, 4, 1, 32000, sanitizeInput(simpleOpcode(0xf5), []uint64{0, 0x2ffff, 0xffff, 0}), 1.5},                     // Sanitize offset, length (not value, salt)
		{"STATICCALL", 0xfa, 6, 1, 100, sanitizeInput(simpleOpcode(0xfa), []uint64{0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3},   // Sanitize argsOffset, argsSize, retOffset, retSize
		{"REVERT", 0xfd, 2, 0, 0, sanitizeInput(simpleOpcode(0xfd), []uint64{0x2ffff, 0xffff}), 0.1},                                // Sanitize offset, length - Lower - ends execution
		{"INVALID", 0xfe, 0, 0, 0, simpleOpcode(0xfe), 0.05},                                                                        // Very low - breaks execution
		{"SELFDESTRUCT", 0xff, 1, 0, 5000, simpleOpcode(0xff), 1.1},                                                                 // Interesting

		// Precompile calls (treated as special opcodes)
		// These consume stack values and use them as inputs to precompiles
		// Using 0x100+ range to avoid collision with real EVM opcodes
		{"ECRECOVER", 0x101, 4, 1, 3000, ecrecoverTemplate, 2.5},   // Precompile 1 - consumes 4 stack items (hash, v, r, s)
		{"SHA256", 0x102, 2, 1, 60, sha256Template, 2.5},           // Precompile 2 - consumes 2 stack items
		{"RIPEMD160", 0x103, 2, 1, 600, ripemd160Template, 2.0},    // Precompile 3 - consumes 2 stack items
		{"IDENTITY", 0x104, 1, 1, 15, identityTemplate, 2.0},       // Precompile 4 - consumes 1 stack item
		{"MODEXP", 0x105, 0, 1, 200, modexpTemplate, 2.8},          // Precompile 5 - special handling, no stack consumption
		{"ECADD", 0x106, 4, 1, 500, ecAddTemplate, 2.8},            // Precompile 6 - consumes 4 stack items (x1, y1, x2, y2)
		{"ECMUL", 0x107, 3, 1, 40000, ecMulTemplate, 2.8},          // Precompile 7 - consumes 3 stack items (x, y, scalar)
		{"ECPAIRING", 0x108, 6, 1, 100000, ecPairingTemplate, 2.8}, // Precompile 8 - consumes 6 stack items (minimum one pair)
		{"BLAKE2F", 0x109, 7, 1, 1, blake2fTemplate, 2.5},          // Precompile 9 - consumes 7 stack items (rounds, h, m, t, f)
		{"POINTEVAL", 0x10a, 6, 1, 50000, pointEvalTemplate, 2.5},  // Precompile 10 - consumes 6 stack items

		// BLS12-381 precompiles (Prague fork)
		{"BLS12_G1ADD", 0x10b, 4, 1, 375, bls12G1AddTemplate, 2.5},              // Precompile 0x0b - G1 point addition
		{"BLS12_G1MSM", 0x10c, 0, 1, 30000, bls12G1MSMTemplate, 2.2},            // Precompile 0x0c - G1 multi-scalar multiplication
		{"BLS12_G2ADD", 0x10d, 8, 1, 600, bls12G2AddTemplate, 2.5},              // Precompile 0x0d - G2 point addition
		{"BLS12_G2MSM", 0x10e, 0, 1, 150000, bls12G2MSMTemplate, 2.2},           // Precompile 0x0e - G2 multi-scalar multiplication
		{"BLS12_PAIRING_CHECK", 0x10f, 12, 1, 37700, bls12PairingTemplate, 2.8}, // Precompile 0x0f - Pairing check
		{"BLS12_MAP_FP_TO_G1", 0x110, 2, 1, 5500, bls12MapFpToG1Template, 2.2},  // Precompile 0x10 - Map field element to G1
		{"BLS12_MAP_FP2_TO_G2", 0x111, 4, 1, 23800, bls12MapFp2G2Template, 2.2}, // Precompile 0x11 - Map field extension element to G2
	}

	// Add PUSH1-PUSH32 opcodes
	for i := 1; i <= 32; i++ {
		pushOpcode := uint16(0x5f + i)
		pushSize := i
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("PUSH%d", i),
			Opcode:      pushOpcode,
			StackInput:  0,
			StackOutput: 1,
			GasCost:     3,
			Template:    g.makePushTemplate(pushOpcode, pushSize),
			Probability: 1.0,
		})
	}

	// Add DUP1-DUP16 opcodes
	for i := 1; i <= 16; i++ {
		dupOpcode := uint16(0x7f + i)
		dupDepth := i
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("DUP%d", i),
			Opcode:      dupOpcode,
			StackInput:  dupDepth,
			StackOutput: dupDepth + 1,
			GasCost:     3,
			Template:    simpleOpcode(byte(dupOpcode)),
			Probability: 1.0,
		})
	}

	// Add SWAP1-SWAP16 opcodes
	for i := 1; i <= 16; i++ {
		swapOpcode := uint16(0x8f + i)
		swapDepth := i + 1
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("SWAP%d", i),
			Opcode:      swapOpcode,
			StackInput:  swapDepth,
			StackOutput: swapDepth,
			GasCost:     3,
			Template:    simpleOpcode(byte(swapOpcode)),
			Probability: 1.0,
		})
	}

	// Store in map for quick lookup
	for _, op := range opcodes {
		g.opcodeInfos[op.Opcode] = op
	}
}

// NewOpcodeGenerator creates a new opcode generator with optional custom seed
func NewOpcodeGenerator(txID uint64, baseSeed string, maxSize int, maxGas uint64) *OpcodeGenerator {
	g := &OpcodeGenerator{
		rng:              NewDeterministicRNGWithSeed(txID, baseSeed),
		stack:            make([]StackItem, 0, 1024),
		bytecode:         make([]byte, 0, maxSize),
		jumpTargets:      make([]int, 0),
		jumpPlaceholders: make([]int, 0),
		maxGas:           maxGas,
		currentGas:       0,
		maxSize:          maxSize,
		opcodeInfos:      make(map[uint16]*OpcodeInfo),
		txID:             txID,
		baseSeed:         baseSeed,
		fuzzMode:         "all", // Default mode
		invalidOpcodes: []byte{
			0x0c, 0x0d, 0x0e, 0x0f, // Invalid opcodes
			0x1e, 0x1f, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		},
	}

	g.initializeOpcodes()
	g.buildValidOpcodeList()

	return g
}

// SetFuzzMode sets the fuzzing mode for the generator
func (g *OpcodeGenerator) SetFuzzMode(mode string) {
	g.fuzzMode = mode
	g.buildValidOpcodeList() // Rebuild the valid opcodes list based on mode
}

// buildValidOpcodeList creates a list of valid opcodes for random selection
func (g *OpcodeGenerator) buildValidOpcodeList() {
	g.validOpcodes = g.validOpcodes[:0] // Clear existing list

	for _, op := range g.opcodeInfos {
		// Filter based on fuzz mode
		switch g.fuzzMode {
		case "opcodes":
			// Only include regular EVM opcodes (exclude precompiles 0x01-0x12)
			if !g.isPrecompileOpcode(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		case "precompiles":
			// Include precompiles + essential opcodes for stack setup and basic operations
			if g.isPrecompileOpcode(op.Opcode) || g.isEssentialForPrecompiles(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		default: // "all" or any other value
			// Include all opcodes
			g.validOpcodes = append(g.validOpcodes, op)
		}
	}
}

// isPrecompileOpcode checks if an opcode represents a precompile call
func (g *OpcodeGenerator) isPrecompileOpcode(opcode uint16) bool {
	// Precompile opcodes are ≥0x100 to avoid collision with real EVM opcodes
	return opcode >= 0x100 && opcode <= 0x111 // 0x100-0x111 for precompiles 1-18
}

// isPushOpcode checks if an opcode is a PUSH instruction
func (g *OpcodeGenerator) isPushOpcode(opcode uint16) bool {
	// PUSH0 is 0x5f, PUSH1-PUSH32 are 0x60-0x7f
	return opcode >= 0x5f && opcode <= 0x7f
}

// isEssentialForPrecompiles checks if an opcode is essential for precompile fuzzing
func (g *OpcodeGenerator) isEssentialForPrecompiles(opcode uint16) bool {
	// Essential opcodes needed for precompile testing:
	// - PUSH opcodes (0x5f-0x7f) for stack setup
	// - STOP (0x00) for termination
	// - DUP opcodes (0x80-0x8f) for stack manipulation
	// - SWAP opcodes (0x90-0x9f) for stack manipulation
	// - POP (0x50) for stack cleanup
	// - MSTORE (0x52) for memory operations (used in precompile calls)
	// - JUMPDEST (0x5b) for valid bytecode structure

	switch {
	case g.isPushOpcode(opcode):
		return true
	case opcode == 0x00: // STOP
		return true
	case opcode == 0x50: // POP
		return true
	case opcode == 0x52: // MSTORE
		return true
	case opcode == 0x5b: // JUMPDEST
		return true
	case opcode >= 0x80 && opcode <= 0x8f: // DUP1-DUP16
		return true
	case opcode >= 0x90 && opcode <= 0x9f: // SWAP1-SWAP16
		return true
	default:
		return false
	}
}

// makePushTemplate creates a template function for PUSH opcodes
func (g *OpcodeGenerator) makePushTemplate(opcode uint16, size int) func(g *OpcodeGenerator) []byte {
	return func(g *OpcodeGenerator) []byte {
		result := make([]byte, 1+size)
		result[0] = byte(opcode) // Cast to byte since PUSH opcodes are always ≤ 0xff

		// Generate random data for PUSH
		data := g.rng.Bytes(size)
		copy(result[1:], data)

		return result
	}
}

// generateJump creates a JUMP instruction with a placeholder target
func (g *OpcodeGenerator) generateJump() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMP (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x56}
}

// generateJumpi creates a JUMPI instruction with a placeholder target
func (g *OpcodeGenerator) generateJumpi() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMPI (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x57}
}

// generateCallWithZeroValue creates CALL/CALLCODE with value=0 override
func (g *OpcodeGenerator) generateCallWithZeroValue(opcode byte) []byte {
	// Only override the value argument (stack position 2) to be 0
	// The sanitization wrapper handles all memory argument sanitization

	// Set value to 0 (stack position 2)
	bytecode := []byte{
		0x60, 0x00, // PUSH1 0
		0x82,   // SWAP3 - move 0 to position 2 (value)
		0x50,   // POP - remove old value
		opcode, // CALL or CALLCODE
	}

	return bytecode
}

// pushSeedAndTxID adds initial stack values for seed and txID tracking
func (g *OpcodeGenerator) pushSeedAndTxID() {
	// Use exact seed bytes (32-byte value, pad or truncate as needed)
	seedBytes := make([]byte, 32)
	if g.baseSeed != "" {
		// Parse hex seed and use exact bytes
		if parsedSeed, err := parseHexSeed(g.baseSeed); err == nil {
			// If seed is longer than 32 bytes, take first 32
			if len(parsedSeed) >= 32 {
				copy(seedBytes, parsedSeed[:32])
			} else {
				// If seed is shorter, copy to the end (big-endian style)
				copy(seedBytes[32-len(parsedSeed):], parsedSeed)
			}
		} else {
			// Fallback: convert string to bytes (for non-hex seeds)
			seedStr := []byte(g.baseSeed)
			if len(seedStr) >= 32 {
				copy(seedBytes, seedStr[:32])
			} else {
				copy(seedBytes[32-len(seedStr):], seedStr)
			}
		}
	}
	// If no seed provided, seedBytes remains all zeros

	// Push seed first (will be deeper on stack)
	seedPush := make([]byte, 33)
	seedPush[0] = 0x7f // PUSH32
	copy(seedPush[1:], seedBytes)
	g.bytecode = append(g.bytecode, seedPush...)
	g.stack = append(g.stack, StackItem{Value: seedBytes, Known: true})
	g.currentGas += 3

	// Push txID (will be on top of stack)
	txIDBytes := make([]byte, 32)
	binary.BigEndian.PutUint64(txIDBytes[24:], g.txID) // Place in low bytes
	txIDPush := make([]byte, 33)
	txIDPush[0] = 0x7f // PUSH32
	copy(txIDPush[1:], txIDBytes)
	g.bytecode = append(g.bytecode, txIDPush...)
	g.stack = append(g.stack, StackItem{Value: txIDBytes, Known: true})
	g.currentGas += 3
}

// Generate creates a valid bytecode sequence
func (g *OpcodeGenerator) Generate() []byte {
	g.bytecode = g.bytecode[:0]
	g.stack = g.stack[:0]
	g.jumpTargets = g.jumpTargets[:0]
	g.jumpPlaceholders = g.jumpPlaceholders[:0]
	g.currentGas = 0

	// Push seed and txID as initial stack values for tracking
	g.pushSeedAndTxID()

	// Generate bytecode
	for len(g.bytecode) < g.maxSize-32 && g.currentGas < g.maxGas-1000 {
		// Randomly place JUMPDESTs (20% chance when we have few targets)
		if len(g.jumpTargets) < 10 && g.rng.Float64() < 0.2 {
			pc := len(g.bytecode)
			g.bytecode = append(g.bytecode, 0x5b) // JUMPDEST
			g.jumpTargets = append(g.jumpTargets, pc)
			g.currentGas += 1
			continue
		}

		if !g.generateNextInstruction() {
			break
		}
	}

	// Ensure we end with a safe terminating instruction
	if len(g.bytecode) < g.maxSize-1 {
		g.bytecode = append(g.bytecode, 0x00) // STOP
	}

	// Fix up jump targets
	g.fixJumpTargets()

	return g.bytecode
}

// fixJumpTargets replaces placeholder jump targets with actual JUMPDEST positions
func (g *OpcodeGenerator) fixJumpTargets() {
	for _, placeholderPos := range g.jumpPlaceholders {
		var target int

		// 10% chance of invalid jump
		if g.rng.Float64() < 0.1 {
			// Generate invalid target
			targetType := g.rng.Intn(3)
			switch targetType {
			case 0: // Jump beyond bytecode
				target = len(g.bytecode) + g.rng.Intn(1000)
			case 1: // Jump to random position (likely not JUMPDEST)
				target = g.rng.Intn(len(g.bytecode))
			case 2: // Jump to data byte (middle of PUSH)
				// Try to find a PUSH instruction and jump into its data
				for i := 0; i < len(g.bytecode)-2; i++ {
					if g.bytecode[i] >= 0x60 && g.bytecode[i] <= 0x7f { // PUSH1-PUSH32
						pushSize := int(g.bytecode[i] - 0x5f)
						if i+pushSize < len(g.bytecode) {
							target = i + 1 + g.rng.Intn(pushSize) // Jump into PUSH data
							break
						}
					}
				}
				if target == 0 {
					target = g.rng.Intn(len(g.bytecode))
				}
			}
		} else {
			// 90% valid jump - pick a JUMPDEST
			if len(g.jumpTargets) > 0 {
				target = g.jumpTargets[g.rng.Intn(len(g.jumpTargets))]
			} else {
				// No JUMPDESTs, generate likely invalid target
				target = g.rng.Intn(len(g.bytecode))
			}
		}

		// Write target as big-endian PUSH2 data
		if placeholderPos+1 < len(g.bytecode) {
			g.bytecode[placeholderPos] = byte(target >> 8)
			g.bytecode[placeholderPos+1] = byte(target)
		}
	}
}

// generateNextInstruction generates the next valid instruction
func (g *OpcodeGenerator) generateNextInstruction() bool {
	// Decide what type of instruction to generate
	choice := g.rng.Float64()

	if choice < 0.001 { // 0.1% chance of invalid opcode
		invalidOp := g.invalidOpcodes[g.rng.Intn(len(g.invalidOpcodes))]
		g.bytecode = append(g.bytecode, invalidOp)
		g.currentGas += 3 // Assume some gas cost
		return true
	}

	if choice < 0.004 { // 0.3% chance of random byte
		g.bytecode = append(g.bytecode, byte(g.rng.Intn(256)))
		g.currentGas += 3
		return true
	}

	// 99.6% chance of valid opcode
	return g.generateValidInstruction()
}

// generateValidInstruction generates a valid instruction that respects stack constraints
func (g *OpcodeGenerator) generateValidInstruction() bool {
	// Filter opcodes that we can actually execute given current stack state
	var candidates []*OpcodeInfo

	for _, op := range g.validOpcodes {
		if len(g.stack) >= op.StackInput &&
			len(g.stack)-op.StackInput+op.StackOutput <= 1024 && // Stack size limit
			g.currentGas+op.GasCost <= g.maxGas {
			candidates = append(candidates, op)
		}
	}

	if len(candidates) == 0 {
		// No valid candidates, try to add some stack items
		if len(g.stack) < 1020 {
			// Add a PUSH1 with random data
			pushData := byte(g.rng.Intn(256))
			g.bytecode = append(g.bytecode, 0x60, pushData) // PUSH1
			g.pushToStack([]byte{pushData}, true)
			g.currentGas += 3
			return true
		}
		return false // Can't generate anything
	}

	// Weight selection towards useful opcodes
	op := g.selectWeightedOpcode(candidates)

	// Generate the instruction
	sequence := op.Template(g)
	if len(g.bytecode)+len(sequence) > g.maxSize {
		return false
	}

	g.bytecode = append(g.bytecode, sequence...)
	g.currentGas += op.GasCost

	// Update stack state
	g.updateStackState(op)

	return true
}

// selectWeightedOpcode selects an opcode with weighted probability
func (g *OpcodeGenerator) selectWeightedOpcode(candidates []*OpcodeInfo) *OpcodeInfo {
	// Prefer PUSH operations when stack is low
	if len(g.stack) < 5 {
		for _, op := range candidates {
			if g.isPushOpcode(op.Opcode) { // PUSH operations
				if g.rng.Float64() < 0.7 {
					return op
				}
			}
		}
	}

	// Prefer stack operations when stack is getting full
	if len(g.stack) > 100 {
		for _, op := range candidates {
			if op.StackInput > op.StackOutput { // Operations that consume more than they produce
				if g.rng.Float64() < 0.6 {
					return op
				}
			}
		}
	}

	// Use weighted selection based on probability field
	totalWeight := 0.0
	for _, op := range candidates {
		totalWeight += op.Probability
	}

	if totalWeight == 0 {
		// Fallback to random selection if no probabilities set
		return candidates[g.rng.Intn(len(candidates))]
	}

	// Select based on weight
	randomValue := g.rng.Float64() * totalWeight
	currentWeight := 0.0

	for _, op := range candidates {
		currentWeight += op.Probability
		if randomValue <= currentWeight {
			return op
		}
	}

	// Fallback to last candidate
	return candidates[len(candidates)-1]
}

// updateStackState updates the virtual stack based on the executed operation
func (g *OpcodeGenerator) updateStackState(op *OpcodeInfo) {
	// For JUMP/JUMPI, we need special handling since they generate complex sequences
	if op.Opcode == 0x56 || op.Opcode == 0x57 { // JUMP or JUMPI
		// These generate PUSH + JUMP/JUMPI sequences
		// The PUSH adds one item, then JUMP/JUMPI consumes it (and condition for JUMPI)
		if op.Opcode == 0x57 { // JUMPI consumes an additional condition from stack
			if len(g.stack) >= 1 {
				g.stack = g.stack[:len(g.stack)-1]
			}
		}
		// No net stack change for JUMP, -1 for JUMPI
		return
	}

	// Standard stack handling for other opcodes
	// Remove consumed items
	if len(g.stack) >= op.StackInput {
		g.stack = g.stack[:len(g.stack)-op.StackInput]
	}

	// Add produced items
	for i := 0; i < op.StackOutput; i++ {
		// Most operations produce unknown values
		known := g.isPushOpcode(op.Opcode) // PUSH operations produce known values
		value := make([]byte, 32)
		if known {
			// For PUSH operations, we know the value
			copy(value, g.rng.Bytes(32))
		}
		g.pushToStack(value, known)
	}
}

// pushToStack adds an item to the virtual stack
func (g *OpcodeGenerator) pushToStack(value []byte, known bool) {
	if len(g.stack) < 1024 {
		item := StackItem{
			Value: make([]byte, 32),
			Known: known,
		}
		copy(item.Value, value)
		g.stack = append(g.stack, item)
	}
}
