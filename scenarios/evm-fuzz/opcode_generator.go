package evmfuzz

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"strings"
)

// StackItem represents an item on the EVM stack
type StackItem struct {
	Value []byte // 32-byte value
	Known bool   // Whether the value is known/deterministic
}

// DeterministicRNG provides deterministic randomness based on transaction ID
type DeterministicRNG struct {
	state   uint64
	counter uint64
}

// parseHexSeed parses a hex string seed, supporting 0x prefix
func parseHexSeed(seed string) ([]byte, error) {
	// Remove 0x prefix if present
	seed = strings.TrimPrefix(seed, "0x")

	// Ensure even length for proper hex decoding
	if len(seed)%2 == 1 {
		seed = "0" + seed
	}

	return hex.DecodeString(seed)
}

// NewDeterministicRNGWithSeed creates a new deterministic RNG with custom base seed
func NewDeterministicRNGWithSeed(txID uint64, baseSeed string) *DeterministicRNG {
	h := sha256.New()

	// If custom seed provided, use it; otherwise use a fixed fallback
	if baseSeed != "" {
		// Expect hex seed, decode it
		seedBytes, err := parseHexSeed(baseSeed)
		if err != nil {
			// Fallback to seed as bytes if not valid hex
			h.Write([]byte(baseSeed))
		} else {
			h.Write(seedBytes)
		}
	} else {
		// Use fixed fallback for deterministic behavior when no seed provided
		binary.Write(h, binary.LittleEndian, uint64(42))
	}

	// Hash seed+txID for better randomness while maintaining reproducibility
	binary.Write(h, binary.LittleEndian, txID)
	binary.Write(h, binary.LittleEndian, uint64(0x1337DEADBEEF))

	seed := binary.LittleEndian.Uint64(h.Sum(nil)[:8])
	if seed == 0 {
		seed = 1
	}

	return &DeterministicRNG{
		state:   seed,
		counter: 0,
	}
}

func (r *DeterministicRNG) Uint64() uint64 {
	r.counter++
	// Use xorshift64* algorithm for deterministic pseudo-randomness
	r.state ^= r.state >> 12
	r.state ^= r.state << 25
	r.state ^= r.state >> 27
	return r.state * 0x2545F4914F6CDD1D
}

func (r *DeterministicRNG) Intn(n int) int {
	if n <= 0 {
		return 0
	}
	return int(r.Uint64() % uint64(n))
}

func (r *DeterministicRNG) Float64() float64 {
	return float64(r.Uint64()) / float64(^uint64(0))
}

func (r *DeterministicRNG) Bytes(n int) []byte {
	result := make([]byte, n)
	for i := 0; i < n; i += 8 {
		val := r.Uint64()
		for j := 0; j < 8 && i+j < n; j++ {
			result[i+j] = byte(val >> (j * 8))
		}
	}
	return result
}

// OpcodeInfo defines properties of an EVM opcode
type OpcodeInfo struct {
	Name        string
	Opcode      uint16 // uint16 to support precompiles (≥0x100) and regular opcodes (≤0xff)
	StackInput  int    // Number of items consumed from stack
	StackOutput int    // Number of items pushed to stack
	GasCost     uint64
	Template    func() []byte // Function to generate valid sequence
	Probability float64       // Relative probability weight for selection (1.0 = normal)
}

// OpcodeGenerator generates valid EVM bytecode sequences with stack tracking
type OpcodeGenerator struct {
	rng              *DeterministicRNG
	transformer      *InputTransformer // For generating edge case inputs
	stackSize        int               // Current stack size during generation
	bytecode         []byte            // Generated bytecode
	jumpTargets      []int             // Valid JUMPDEST positions (PC values)
	jumpPlaceholders []int             // Positions in bytecode where we need to fix jump targets
	maxGas           uint64            // Maximum gas limit
	currentGas       uint64            // Current gas usage
	maxSize          int               // Maximum bytecode size
	opcodeCount      int               // Current opcode count (PC-based instruction count)
	maxOpcodeCount   int               // Maximum allowed opcodes (derived from maxSize with 10x limit)
	opcodeInfos      map[uint16]*OpcodeInfo
	validOpcodes     []*OpcodeInfo
	invalidOpcodes   []byte
	txID             uint64 // Transaction ID for tracking
	baseSeed         string // Base seed for reproducibility
	fuzzMode         string // Fuzzing mode: "all", "opcodes", "precompiles"
}

// Template functions for opcodes
func simpleOpcode(opcode byte) func() []byte {
	return func() []byte { return []byte{opcode} }
}

// Generic sanitization wrapper - applies masks to stack positions before executing base template
// masks[i] = mask for stack position i (0 = no sanitization)
func sanitizeInput(baseTemplate func() []byte, masks []uint64) func() []byte {
	return func() []byte {
		var bytecode []byte

		// Apply sanitization to each specified stack position
		for i, mask := range masks {
			if mask == 0 {
				continue // Skip positions that don't need sanitization
			}

			// Generate appropriate PUSH instruction for the mask
			var pushBytes []byte
			if mask <= 0xFF {
				pushBytes = []byte{0x60, byte(mask)} // PUSH1
			} else if mask <= 0xFFFF {
				pushBytes = []byte{0x61, byte(mask >> 8), byte(mask)} // PUSH2
			} else if mask <= 0x2ffff {
				pushBytes = []byte{0x62, byte(mask >> 16), byte(mask >> 8), byte(mask)} // PUSH3
			} else {
				pushBytes = []byte{0x63, byte(mask >> 24), byte(mask >> 16), byte(mask >> 8), byte(mask)} // PUSH4
			}

			if i == 0 {
				// Sanitize stack[0] (top of stack)
				bytecode = append(bytecode, pushBytes...)
				bytecode = append(bytecode, 0x16) // AND
			} else {
				// Sanitize stack[i] - need to use DUP to copy to top, sanitize, then SWAP back
				dupOpcode := byte(0x80 + i)  // DUP(i+1)
				swapOpcode := byte(0x90 + i) // SWAP(i+1)

				bytecode = append(bytecode, dupOpcode)    // DUP(i+1) - copy stack[i] to top
				bytecode = append(bytecode, pushBytes...) // PUSH mask
				bytecode = append(bytecode, 0x16)         // AND (sanitize)
				bytecode = append(bytecode, swapOpcode)   // SWAP(i+1) - put sanitized value back
				bytecode = append(bytecode, 0x50)         // POP (remove original unsanitized value)
			}
		}

		// Execute the base template
		baseBytes := baseTemplate()
		bytecode = append(bytecode, baseBytes...)

		return bytecode
	}
}

// initializeOpcodes sets up the opcode definitions with sanitization
func (g *OpcodeGenerator) initializeOpcodes() {
	opcodes := []*OpcodeInfo{
		{"STOP", 0x00, 0, 0, 0, simpleOpcode(0x00), 0},

		// Stack operations
		{"ADD", 0x01, 2, 1, 3, simpleOpcode(0x01), 1.0},
		{"MUL", 0x02, 2, 1, 5, simpleOpcode(0x02), 1.0},
		{"SUB", 0x03, 2, 1, 3, simpleOpcode(0x03), 1.0},
		{"DIV", 0x04, 2, 1, 5, simpleOpcode(0x04), 1.0},
		{"SDIV", 0x05, 2, 1, 5, simpleOpcode(0x05), 1.0},
		{"MOD", 0x06, 2, 1, 5, simpleOpcode(0x06), 1.0},
		{"SMOD", 0x07, 2, 1, 5, simpleOpcode(0x07), 1.0},
		{"ADDMOD", 0x08, 3, 1, 8, simpleOpcode(0x08), 1.0},
		{"MULMOD", 0x09, 3, 1, 8, simpleOpcode(0x09), 1.0},
		{"EXP", 0x0a, 2, 1, 10, simpleOpcode(0x0a), 1.0},
		{"SIGNEXTEND", 0x0b, 2, 1, 5, simpleOpcode(0x0b), 1.0},

		// Comparison operations
		{"LT", 0x10, 2, 1, 3, simpleOpcode(0x10), 1.0},
		{"GT", 0x11, 2, 1, 3, simpleOpcode(0x11), 1.0},
		{"SLT", 0x12, 2, 1, 3, simpleOpcode(0x12), 1.0},
		{"SGT", 0x13, 2, 1, 3, simpleOpcode(0x13), 1.0},
		{"EQ", 0x14, 2, 1, 3, simpleOpcode(0x14), 1.0},
		{"ISZERO", 0x15, 1, 1, 3, simpleOpcode(0x15), 1.0},
		{"AND", 0x16, 2, 1, 3, simpleOpcode(0x16), 1.0},
		{"OR", 0x17, 2, 1, 3, simpleOpcode(0x17), 1.0},
		{"XOR", 0x18, 2, 1, 3, simpleOpcode(0x18), 1.0},
		{"NOT", 0x19, 1, 1, 3, simpleOpcode(0x19), 1.0},
		{"BYTE", 0x1a, 2, 1, 3, sanitizeInput(simpleOpcode(0x1a), []uint64{0x3f}), 1.0},
		{"SHL", 0x1b, 2, 1, 3, simpleOpcode(0x1b), 1.0},
		{"SHR", 0x1c, 2, 1, 3, simpleOpcode(0x1c), 1.0},
		{"SAR", 0x1d, 2, 1, 3, simpleOpcode(0x1d), 1.0},
		{"CLZ", 0x1e, 1, 1, 3, simpleOpcode(0x1e), 1.5},

		// Crypto operations
		{"KECCAK256", 0x20, 2, 1, 30, sanitizeInput(simpleOpcode(0x20), []uint64{0x2ffff, 0xffff}), 1.5}, // Sanitize offset and length

		// Environmental information
		{"ADDRESS", 0x30, 0, 1, 2, simpleOpcode(0x30), 2.0},
		{"BALANCE", 0x31, 1, 1, 100, simpleOpcode(0x31), 2.2},
		{"ORIGIN", 0x32, 0, 1, 2, simpleOpcode(0x32), 2.0},
		{"CALLER", 0x33, 0, 1, 2, simpleOpcode(0x33), 2.0},
		{"CALLVALUE", 0x34, 0, 1, 2, simpleOpcode(0x34), 2.0},
		{"CALLDATALOAD", 0x35, 1, 1, 3, simpleOpcode(0x35), 2.0},
		{"CALLDATASIZE", 0x36, 0, 1, 2, simpleOpcode(0x36), 2.0},
		{"CALLDATACOPY", 0x37, 3, 0, 3, sanitizeInput(simpleOpcode(0x37), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"CODESIZE", 0x38, 0, 1, 2, simpleOpcode(0x38), 2.0},
		{"CODECOPY", 0x39, 3, 0, 3, sanitizeInput(simpleOpcode(0x39), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"GASPRICE", 0x3a, 0, 1, 2, simpleOpcode(0x3a), 2.0},
		{"EXTCODESIZE", 0x3b, 1, 1, 100, simpleOpcode(0x3b), 2.0},
		{"EXTCODECOPY", 0x3c, 4, 0, 100, sanitizeInput(simpleOpcode(0x3c), []uint64{0, 0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length (not address)
		{"RETURNDATASIZE", 0x3d, 0, 1, 2, simpleOpcode(0x3d), 2.0},
		{"RETURNDATACOPY", 0x3e, 3, 0, 3, sanitizeInput(simpleOpcode(0x3e), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, length
		{"EXTCODEHASH", 0x3f, 1, 1, 100, simpleOpcode(0x3f), 2.0},

		// Block information
		{"BLOCKHASH", 0x40, 1, 1, 20, simpleOpcode(0x40), 2.0},
		{"COINBASE", 0x41, 0, 1, 2, simpleOpcode(0x41), 2.0},
		{"TIMESTAMP", 0x42, 0, 1, 2, simpleOpcode(0x42), 2.0},
		{"NUMBER", 0x43, 0, 1, 2, simpleOpcode(0x43), 2.0},
		{"DIFFICULTY", 0x44, 0, 1, 2, simpleOpcode(0x44), 2.0},
		{"GASLIMIT", 0x45, 0, 1, 2, simpleOpcode(0x45), 2.0},
		{"CHAINID", 0x46, 0, 1, 2, simpleOpcode(0x46), 2.5},
		{"SELFBALANCE", 0x47, 0, 1, 5, simpleOpcode(0x47), 2.5},
		{"BASEFEE", 0x48, 0, 1, 2, simpleOpcode(0x48), 2.5},
		{"BLOBHASH", 0x49, 1, 1, 3, simpleOpcode(0x49), 2.0},
		{"BLOBBASEFEE", 0x4a, 0, 1, 2, simpleOpcode(0x4a), 2.0},

		// Stack operations with memory/storage sanitization
		{"POP", 0x50, 1, 0, 2, simpleOpcode(0x50), 1.0},
		{"MLOAD", 0x51, 1, 1, 3, sanitizeInput(simpleOpcode(0x51), []uint64{0x2ffff}), 1.0},    // Sanitize offset
		{"MSTORE", 0x52, 2, 0, 3, sanitizeInput(simpleOpcode(0x52), []uint64{0x2ffff}), 1.0},   // Sanitize offset
		{"MSTORE8", 0x53, 2, 0, 3, sanitizeInput(simpleOpcode(0x53), []uint64{0x2ffff}), 1.0},  // Sanitize offset
		{"SLOAD", 0x54, 1, 1, 100, sanitizeInput(simpleOpcode(0x54), []uint64{0x2ffff}), 1.2},  // Sanitize storage key
		{"SSTORE", 0x55, 2, 0, 100, sanitizeInput(simpleOpcode(0x55), []uint64{0x2ffff}), 1.2}, // Sanitize storage key
		{"JUMP", 0x56, 0, 0, 8, g.generateJump, 1.0},
		{"JUMPI", 0x57, 1, 0, 10, g.generateJumpi, 1.0},
		{"PC", 0x58, 0, 1, 2, simpleOpcode(0x58), 1.0},
		{"MSIZE", 0x59, 0, 1, 2, simpleOpcode(0x59), 1.0},
		{"GAS", 0x5a, 0, 1, 2, simpleOpcode(0x5a), 1.0},
		{"JUMPDEST", 0x5b, 0, 0, 1, simpleOpcode(0x5b), 1.0},
		{"TLOAD", 0x5c, 1, 1, 100, sanitizeInput(simpleOpcode(0x5c), []uint64{0x2ffff}), 2.0},                // Sanitize storage key
		{"TSTORE", 0x5d, 2, 0, 100, sanitizeInput(simpleOpcode(0x5d), []uint64{0x2ffff}), 2.0},               // Sanitize storage key
		{"MCOPY", 0x5e, 3, 0, 3, sanitizeInput(simpleOpcode(0x5e), []uint64{0x2ffff, 0x2ffff, 0xffff}), 2.0}, // Sanitize destOffset, offset, size

		// Push operations (PUSH1-PUSH32)
		{"PUSH0", 0x5f, 0, 1, 2, simpleOpcode(0x5f), 1.0},
		// PUSH1-PUSH32, SWAP* & DUP* added below

		// Log operations - sanitize memory offset
		{"LOG0", 0xa0, 2, 0, 375, sanitizeInput(simpleOpcode(0xa0), []uint64{0x2ffff, 0xffff}), 1.0},  // Sanitize offset
		{"LOG1", 0xa1, 3, 0, 750, sanitizeInput(simpleOpcode(0xa1), []uint64{0x2ffff, 0xffff}), 1.0},  // Sanitize offset
		{"LOG2", 0xa2, 4, 0, 1125, sanitizeInput(simpleOpcode(0xa2), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset
		{"LOG3", 0xa3, 5, 0, 1500, sanitizeInput(simpleOpcode(0xa3), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset
		{"LOG4", 0xa4, 6, 0, 1875, sanitizeInput(simpleOpcode(0xa4), []uint64{0x2ffff, 0xffff}), 1.0}, // Sanitize offset

		// Contract operations
		{"CREATE", 0xf0, 3, 1, 32000, g.createTemplate, 1.8},                                                                            // Enhanced CREATE with deployment + call
		{"CALL", 0xf1, 6, 1, 100, sanitizeInput(simpleOpcode(0xf1), []uint64{0, 0xffff, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3},     // Sanitize memory args, custom value=0
		{"CALLCODE", 0xf2, 6, 1, 100, sanitizeInput(simpleOpcode(0xf2), []uint64{0, 0xffff, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.0}, // Sanitize memory args, custom value=0
		{"RETURN", 0xf3, 2, 0, 0, sanitizeInput(simpleOpcode(0xf3), []uint64{0x2ffff, 0xffff}), 0.1},                                    // Sanitize offset, length - Lower - ends execution
		{"DELEGATECALL", 0xf4, 6, 1, 100, sanitizeInput(simpleOpcode(0xf4), []uint64{0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3},     // Sanitize argsOffset, argsSize, retOffset, retSize
		{"CREATE2", 0xf5, 4, 1, 32000, g.create2Template, 1.8},                                                                          // Enhanced CREATE2 with deployment + call
		{"STATICCALL", 0xfa, 6, 1, 100, sanitizeInput(simpleOpcode(0xfa), []uint64{0, 0, 0x2ffff, 0xffff, 0x2ffff, 0xffff}), 1.3},       // Sanitize argsOffset, argsSize, retOffset, retSize
		{"REVERT", 0xfd, 2, 0, 0, sanitizeInput(simpleOpcode(0xfd), []uint64{0x2ffff, 0xffff}), 0.1},                                    // Sanitize offset, length - Lower - ends execution
		{"SELFDESTRUCT", 0xff, 1, 0, 5000, simpleOpcode(0xff), 1.1},

		// Precompile calls (treated as special opcodes)
		// Specialized handlers generate proper calldata and push results to stack
		// Using 0x100+ range to avoid collision with real EVM opcodes
		{"ECRECOVER", 0x101, 0, 1, 3000, g.generateEcrecoverCall, 2.5},      // Precompile 1 - returns 32 bytes (address or 0)
		{"SHA256", 0x102, 0, 1, 60, g.generateSha256Call, 2.5},              // Precompile 2 - returns 32 bytes (hash)
		{"RIPEMD160", 0x103, 0, 1, 600, g.generateRipemd160Call, 2.0},       // Precompile 3 - returns 32 bytes (hash, right-padded)
		{"IDENTITY", 0x104, 0, 1, 15, g.generateIdentityCall, 2.0},          // Precompile 4 - returns variable length (input data)
		{"MODEXP", 0x105, 0, 1, 200, g.generateModexpCall, 2.8},             // Precompile 5 - returns variable length (modexp result)
		{"ECADD", 0x106, 0, 2, 500, g.generateBN256EcAddCall, 2.8},          // Precompile 6 - returns 64 bytes (x, y coordinates)
		{"ECMUL", 0x107, 0, 2, 40000, g.generateBN256EcMulCall, 2.8},        // Precompile 7 - returns 64 bytes (x, y coordinates)
		{"ECPAIRING", 0x108, 0, 1, 100000, g.generateBN256PairingCall, 2.8}, // Precompile 8 - returns 32 bytes (0 or 1)
		{"BLAKE2F", 0x109, 0, 2, 1, g.generateBlake2fCall, 2.5},             // Precompile 9 - returns 64 bytes (blake2f hash)
		{"POINTEVAL", 0x10a, 0, 1, 50000, g.generateKZGPointEvalCall, 2.5},  // Precompile 10 - returns 32 bytes (0 or 1)

		// BLS12-381 precompiles (Prague fork)
		{"BLS12_G1ADD", 0x10b, 0, 4, 375, g.generateBLS12G1AddCall, 2.5},              // Precompile 0x0b - returns 128 bytes (G1 point)
		{"BLS12_G1MSM", 0x10c, 0, 4, 30000, g.generateBLS12G1MSMCall, 2.2},            // Precompile 0x0c - returns 128 bytes (G1 point)
		{"BLS12_G2ADD", 0x10d, 0, 8, 600, g.generateBLS12G2AddCall, 2.5},              // Precompile 0x0d - returns 256 bytes (G2 point)
		{"BLS12_G2MSM", 0x10e, 0, 8, 150000, g.generateBLS12G2MSMCall, 2.2},           // Precompile 0x0e - returns 256 bytes (G2 point)
		{"BLS12_PAIRING_CHECK", 0x10f, 0, 1, 37700, g.generateBLS12PairingCall, 2.8},  // Precompile 0x0f - returns 32 bytes (0 or 1)
		{"BLS12_MAP_FP_TO_G1", 0x110, 0, 4, 5500, g.generateBLS12MapFpToG1Call, 2.2},  // Precompile 0x10 - returns 128 bytes (G1 point)
		{"BLS12_MAP_FP2_TO_G2", 0x111, 0, 8, 23800, g.generateBLS12MapFp2G2Call, 2.2}, // Precompile 0x11 - returns 256 bytes (G2 point)
	}

	// Add PUSH1-PUSH32 opcodes
	for i := 1; i <= 32; i++ {
		pushOpcode := uint16(0x5f + i)
		pushSize := i
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("PUSH%d", i),
			Opcode:      pushOpcode,
			StackInput:  0,
			StackOutput: 1,
			GasCost:     3,
			Template:    g.makePushTemplate(pushOpcode, pushSize),
			Probability: 1.0,
		})
	}

	// Add DUP1-DUP16 opcodes
	for i := 1; i <= 16; i++ {
		dupOpcode := uint16(0x7f + i)
		dupDepth := i
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("DUP%d", i),
			Opcode:      dupOpcode,
			StackInput:  dupDepth,
			StackOutput: dupDepth + 1,
			GasCost:     3,
			Template:    simpleOpcode(byte(dupOpcode)),
			Probability: 1.0,
		})
	}

	// Add SWAP1-SWAP16 opcodes
	for i := 1; i <= 16; i++ {
		swapOpcode := uint16(0x8f + i)
		swapDepth := i + 1
		opcodes = append(opcodes, &OpcodeInfo{
			Name:        fmt.Sprintf("SWAP%d", i),
			Opcode:      swapOpcode,
			StackInput:  swapDepth,
			StackOutput: swapDepth,
			GasCost:     3,
			Template:    simpleOpcode(byte(swapOpcode)),
			Probability: 1.0,
		})
	}

	// Store in map for quick lookup
	for _, op := range opcodes {
		g.opcodeInfos[op.Opcode] = op
	}
}

// NewOpcodeGenerator creates a new opcode generator with optional custom seed
func NewOpcodeGenerator(txID uint64, baseSeed string, maxSize int, maxGas uint64) *OpcodeGenerator {
	rng := NewDeterministicRNGWithSeed(txID, baseSeed)
	g := &OpcodeGenerator{
		rng:              rng,
		transformer:      NewInputTransformer(rng),
		stackSize:        0,
		bytecode:         make([]byte, 0, maxSize),
		jumpTargets:      make([]int, 0),
		jumpPlaceholders: make([]int, 0),
		maxGas:           maxGas,
		currentGas:       0,
		maxSize:          maxSize,
		opcodeCount:      0,
		maxOpcodeCount:   maxSize * 10, // Allow up to 10x the PC size in actual opcodes
		opcodeInfos:      make(map[uint16]*OpcodeInfo),
		txID:             txID,
		baseSeed:         baseSeed,
		fuzzMode:         "all", // Default mode
	}

	g.initializeOpcodes()
	g.buildValidOpcodeList()
	g.buildInvalidOpcodeList()

	return g
}

// SetFuzzMode sets the fuzzing mode for the generator
func (g *OpcodeGenerator) SetFuzzMode(mode string) {
	g.fuzzMode = mode
	g.buildValidOpcodeList()   // Rebuild the valid opcodes list based on mode
	g.buildInvalidOpcodeList() // Rebuild the invalid opcodes list
}

// buildValidOpcodeList creates a list of valid opcodes for random selection
func (g *OpcodeGenerator) buildValidOpcodeList() {
	g.validOpcodes = g.validOpcodes[:0] // Clear existing list

	for _, op := range g.opcodeInfos {
		// Filter based on fuzz mode
		switch g.fuzzMode {
		case "opcodes":
			// Only include regular EVM opcodes (exclude precompiles 0x01-0x12)
			if !g.isPrecompileOpcode(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		case "precompiles":
			// Only include precompiles - they generate their own complete bytecode internally
			if g.isPrecompileOpcode(op.Opcode) {
				g.validOpcodes = append(g.validOpcodes, op)
			}
		default: // "all" or any other value
			// Include all opcodes
			g.validOpcodes = append(g.validOpcodes, op)
		}
	}
}

// buildInvalidOpcodeList creates a list of invalid opcodes by finding gaps in valid opcodes
func (g *OpcodeGenerator) buildInvalidOpcodeList() {
	// Create a set of valid opcodes (only regular EVM opcodes, not precompiles)
	validOpcodeSet := make(map[byte]bool)

	for _, op := range g.opcodeInfos {
		// Only consider regular EVM opcodes (0x00-0xFF), not precompiles (≥0x100)
		if op.Opcode <= 0xFF {
			validOpcodeSet[byte(op.Opcode)] = true
		}
	}

	// Find all invalid opcodes in the 0x00-0xFF range
	g.invalidOpcodes = g.invalidOpcodes[:0] // Clear existing list

	for opcode := 0; opcode <= 0xFF; opcode++ {
		if !validOpcodeSet[byte(opcode)] {
			g.invalidOpcodes = append(g.invalidOpcodes, byte(opcode))
		}
	}
}

// GetInvalidOpcodes returns a copy of the invalid opcodes list (for testing/debugging)
func (g *OpcodeGenerator) GetInvalidOpcodes() []byte {
	result := make([]byte, len(g.invalidOpcodes))
	copy(result, g.invalidOpcodes)
	return result
}

// isPrecompileOpcode checks if an opcode represents a precompile call
func (g *OpcodeGenerator) isPrecompileOpcode(opcode uint16) bool {
	// Precompile opcodes are ≥0x100 to avoid collision with real EVM opcodes
	return opcode >= 0x100 && opcode <= 0x111 // 0x100-0x111 for precompiles 1-18
}

// isPushOpcode checks if an opcode is a PUSH instruction
func (g *OpcodeGenerator) isPushOpcode(opcode uint16) bool {
	// PUSH0 is 0x5f, PUSH1-PUSH32 are 0x60-0x7f
	return opcode >= 0x5f && opcode <= 0x7f
}

// countOpcodesInBytecode counts the number of opcodes in a bytecode sequence
// This properly handles PUSH opcodes which consume data bytes
func (g *OpcodeGenerator) countOpcodesInBytecode(bytecode []byte) int {
	count := 0
	pc := 0

	for pc < len(bytecode) {
		opcode := bytecode[pc]
		count++

		// Handle PUSH opcodes which consume additional bytes
		if opcode >= 0x60 && opcode <= 0x7f { // PUSH1-PUSH32
			pushSize := int(opcode - 0x5f) // PUSH1=1, PUSH2=2, ..., PUSH32=32
			pc += pushSize + 1             // Skip opcode + push data
		} else if opcode == 0x5f { // PUSH0
			pc++ // Just the opcode, no data
		} else {
			pc++ // Regular opcode
		}
	}

	return count
}

func (g *OpcodeGenerator) createTemplate() []byte  { return g.generateCreate(false) }
func (g *OpcodeGenerator) create2Template() []byte { return g.generateCreate(true) }

// makePushTemplate creates a template function for PUSH opcodes
func (g *OpcodeGenerator) makePushTemplate(opcode uint16, size int) func() []byte {
	return func() []byte {
		result := make([]byte, 1+size)
		result[0] = byte(opcode) // Cast to byte since PUSH opcodes are always ≤ 0xff

		// Generate random data for PUSH
		data := g.rng.Bytes(size)
		copy(result[1:], data)

		return result
	}
}

// generateJump creates a JUMP instruction with a placeholder target
func (g *OpcodeGenerator) generateJump() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMP (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x56}
}

// generateJumpi creates a JUMPI instruction with a placeholder target
func (g *OpcodeGenerator) generateJumpi() []byte {
	// Always use PUSH2 for jump targets to have consistent size
	// Record position where we need to fix the target later
	g.jumpPlaceholders = append(g.jumpPlaceholders, len(g.bytecode)+1)

	// PUSH2 0x0000 JUMPI (placeholder target)
	return []byte{0x61, 0x00, 0x00, 0x57}
}

// generateCreate creates enhanced CREATE/CREATE2 with 50% chance of full deployment + call
func (g *OpcodeGenerator) generateCreate(isCreate2 bool) []byte {
	// 60% chance for enhanced deployment with subsequent call
	if g.rng.Float64() < 0.6 {
		return g.generateCreateWithCall(isCreate2)
	}

	// 40% chance for simple CREATE/CREATE2 (existing behavior)
	if isCreate2 {
		return []byte{0xf5} // CREATE2
	}
	return []byte{0xf0} // CREATE
}

// generateCreateWithCall implements the full deployment + call pattern
func (g *OpcodeGenerator) generateCreateWithCall(isCreate2 bool) []byte {
	var bytecode []byte

	// Step 1: Load current bytecode into memory at offset 0
	// CODESIZE - get size of current contract code
	bytecode = append(bytecode, 0x38) // CODESIZE

	// DUP1 - duplicate size for CODECOPY
	bytecode = append(bytecode, 0x80) // DUP1

	// PUSH0 - source offset in code
	bytecode = append(bytecode, 0x5f) // PUSH0

	// PUSH0 - destination offset in memory
	bytecode = append(bytecode, 0x5f) // PUSH0

	// CODECOPY - copy current code to memory[0:]
	bytecode = append(bytecode, 0x39) // CODECOPY

	// Step 2: Overwrite first 32 bytes with jump bypass pattern
	// We need to create: PUSH4 0x00000000 JUMP PUSH26 <remaining_bytes>
	// Calculate the jump target first (it will be at the end of this sequence)

	// Create the bypass pattern (32 bytes total)
	bypassPattern := make([]byte, 32)
	bypassPattern[0] = 0x63 // PUSH4
	// 1-4 are 0x00000000
	bypassPattern[5] = 0x56 // JUMP
	bypassPattern[6] = 0x79 // PUSH26
	// bytes 7-32 are PUSH26 data (can be anything, we'll use random)
	copy(bypassPattern[7:], g.rng.Bytes(25))

	// Store the bypass pattern in memory starting at offset 0
	// PUSH32 <byte> - push the byte value
	bytecode = append(bytecode, 0x7f)
	jumpAddrPos := len(bytecode) + 1 // position of the jump address
	bytecode = append(bytecode, bypassPattern...)
	// PUSH0 - push memory offset
	bytecode = append(bytecode, 0x5f)
	// MSTORE - store word in memory
	bytecode = append(bytecode, 0x52)

	// Step 3: Prepare CREATE/CREATE2 arguments
	// For CREATE: value, offset, size
	// For CREATE2: value, offset, size, salt

	// push salt
	if isCreate2 {
		// PUSH4 <random_salt> - salt for CREATE2
		salt := g.rng.Bytes(4)
		bytecode = append(bytecode, 0x63)
		bytecode = append(bytecode, salt...)

		// SWAP1 - swap salt with size
		bytecode = append(bytecode, 0x90)
	}

	// PUSH0 - offset
	bytecode = append(bytecode, 0x5f)

	// Push value - 30% chance for random value, 70% chance for 0
	if g.rng.Float64() < 0.3 {
		// Random value between 0xa000-0xffff
		randomValue := 0xa000 + g.rng.Intn(0x6000)                                 // 0xa000 + [0, 0x5fff] = [0xa000, 0xffff]
		bytecode = append(bytecode, 0x61, byte(randomValue>>8), byte(randomValue)) // PUSH2
	} else {
		// PUSH0 - value (0 ETH)
		bytecode = append(bytecode, 0x5f)
	}

	if isCreate2 {
		// CREATE2
		bytecode = append(bytecode, 0xf5)
	} else {
		// CREATE
		bytecode = append(bytecode, 0xf0)
	}

	// Step 4: Call into the newly created contract
	// Determine call type (40% call, 40% delegatecall, 10% staticcall, 10% callcode)
	callChoice := g.rng.Float64()

	if callChoice < 0.4 { // 40% CALL
		// Prepare CALL arguments: gas, address, value, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - value
		bytecode = append(bytecode, 0x85) // DUP6 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf1) // CALL
	} else if callChoice < 0.8 { // 40% DELEGATECALL
		// Prepare DELEGATECALL arguments: gas, address, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x84) // DUP5 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf4) // DELEGATECALL
	} else if callChoice < 0.9 { // 10% STATICCALL
		// Prepare STATICCALL arguments: gas, address, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x84) // DUP5 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xfa) // STATICCALL
	} else { // 10% CALLCODE
		// Prepare CALLCODE arguments: gas, address, value, argsOffset, argsSize, retOffset, retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - retOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsSize
		bytecode = append(bytecode, 0x5f) // PUSH0 - argsOffset
		bytecode = append(bytecode, 0x5f) // PUSH0 - value
		bytecode = append(bytecode, 0x85) // DUP6 - address
		bytecode = append(bytecode, 0x5a) // GAS - use all available gas
		bytecode = append(bytecode, 0xf2) // CALLCODE
	}

	// Step 5: Add JUMPDEST for the inner call entrypoint
	// Record the position where we need to place the JUMPDEST
	jumpdestPos := len(g.bytecode) + len(bytecode)
	g.jumpTargets = append(g.jumpTargets, jumpdestPos)

	// update jump address
	bytecode[jumpAddrPos+1] = byte(jumpdestPos >> 16)
	bytecode[jumpAddrPos+2] = byte(jumpdestPos >> 8)
	bytecode[jumpAddrPos+3] = byte(jumpdestPos)

	// Add the JUMPDEST
	bytecode = append(bytecode, 0x5b) // JUMPDEST
	g.stackSize = 0                   // clear stack to avoid underflow in inner call

	return bytecode
}

// pushSeedAndTxID adds initial stack values for seed and txID tracking
func (g *OpcodeGenerator) pushSeedAndTxID() {
	// Use exact seed bytes (32-byte value, pad or truncate as needed)
	seedBytes := make([]byte, 32)
	if g.baseSeed != "" {
		// Parse hex seed and use exact bytes
		if parsedSeed, err := parseHexSeed(g.baseSeed); err == nil {
			// If seed is longer than 32 bytes, take first 32
			if len(parsedSeed) >= 32 {
				copy(seedBytes, parsedSeed[:32])
			} else {
				// If seed is shorter, copy to the end (big-endian style)
				copy(seedBytes[32-len(parsedSeed):], parsedSeed)
			}
		} else {
			// Fallback: convert string to bytes (for non-hex seeds)
			seedStr := []byte(g.baseSeed)
			if len(seedStr) >= 32 {
				copy(seedBytes, seedStr[:32])
			} else {
				copy(seedBytes[32-len(seedStr):], seedStr)
			}
		}
	}
	// If no seed provided, seedBytes remains all zeros

	// Push seed first (will be deeper on stack)
	seedPush := make([]byte, 33)
	seedPush[0] = 0x7f // PUSH32
	copy(seedPush[1:], seedBytes)
	g.bytecode = append(g.bytecode, seedPush...)
	g.stackSize += 1
	g.currentGas += 3

	// Push txID (will be on top of stack)
	txIDBytes := make([]byte, 32)
	binary.BigEndian.PutUint64(txIDBytes[24:], g.txID) // Place in low bytes
	txIDPush := make([]byte, 33)
	txIDPush[0] = 0x7f // PUSH32
	copy(txIDPush[1:], txIDBytes)
	g.bytecode = append(g.bytecode, txIDPush...)
	g.stackSize += 1
	g.currentGas += 3
}

// Generate creates a valid bytecode sequence
func (g *OpcodeGenerator) Generate() []byte {
	g.bytecode = g.bytecode[:0]
	g.stackSize = 0
	g.jumpTargets = g.jumpTargets[:0]
	g.jumpPlaceholders = g.jumpPlaceholders[:0]
	g.currentGas = 0
	g.opcodeCount = 0

	// Push seed and txID as initial stack values for tracking
	g.pushSeedAndTxID()
	// Count the initial PUSH operations (2 PUSH32 opcodes)
	g.opcodeCount += 2

	// Generate bytecode
	for len(g.bytecode) < g.maxSize-32 && g.currentGas < g.maxGas-1000 && g.opcodeCount < g.maxOpcodeCount-10 {
		// Randomly place JUMPDESTs (20% chance when we have few targets)
		if len(g.jumpTargets) < 10 && g.rng.Float64() < 0.2 {
			pc := len(g.bytecode)
			g.bytecode = append(g.bytecode, 0x5b) // JUMPDEST
			g.jumpTargets = append(g.jumpTargets, pc)
			g.currentGas += 1
			g.opcodeCount += 1 // Count the JUMPDEST opcode
			continue
		}

		if !g.generateNextInstruction() {
			break
		}
	}

	// Ensure we end with a safe terminating instruction
	if len(g.bytecode) < g.maxSize-1 && g.opcodeCount < g.maxOpcodeCount {
		g.bytecode = append(g.bytecode, 0x00) // STOP
		g.opcodeCount += 1                    // Count the STOP opcode
	}

	// Fix up jump targets
	g.fixJumpTargets()

	return g.bytecode
}

// fixJumpTargets replaces placeholder jump targets with actual JUMPDEST positions
func (g *OpcodeGenerator) fixJumpTargets() {
	for _, placeholderPos := range g.jumpPlaceholders {
		var target int

		// 10% chance of invalid jump
		if g.rng.Float64() < 0.1 {
			// Generate invalid target
			targetType := g.rng.Intn(3)
			switch targetType {
			case 0: // Jump beyond bytecode
				target = len(g.bytecode) + g.rng.Intn(1000)
			case 1: // Jump to random position (likely not JUMPDEST)
				target = g.rng.Intn(len(g.bytecode))
			case 2: // Jump to data byte (middle of PUSH)
				// Try to find a PUSH instruction and jump into its data
				for i := 0; i < len(g.bytecode)-2; i++ {
					if g.bytecode[i] >= 0x60 && g.bytecode[i] <= 0x7f { // PUSH1-PUSH32
						pushSize := int(g.bytecode[i] - 0x5f)
						if i+pushSize < len(g.bytecode) {
							target = i + 1 + g.rng.Intn(pushSize) // Jump into PUSH data
							break
						}
					}
				}
				if target == 0 {
					target = g.rng.Intn(len(g.bytecode))
				}
			}
		} else {
			// 90% valid jump - pick a JUMPDEST
			if len(g.jumpTargets) > 0 {
				target = g.jumpTargets[g.rng.Intn(len(g.jumpTargets))]
			} else {
				// No JUMPDESTs, generate likely invalid target
				target = g.rng.Intn(len(g.bytecode))
			}
		}

		// Write target as big-endian PUSH2 data
		if placeholderPos+1 < len(g.bytecode) {
			g.bytecode[placeholderPos] = byte(target >> 8)
			g.bytecode[placeholderPos+1] = byte(target)
		}
	}
}

// generateNextInstruction generates the next valid instruction
func (g *OpcodeGenerator) generateNextInstruction() bool {
	// Decide what type of instruction to generate
	choice := g.rng.Float64()

	if choice < 0.001 { // 0.1% chance of invalid opcode
		invalidOp := g.invalidOpcodes[g.rng.Intn(len(g.invalidOpcodes))]
		g.bytecode = append(g.bytecode, invalidOp)
		g.currentGas += 3  // Assume some gas cost
		g.opcodeCount += 1 // Count the invalid opcode
		return true
	}

	if choice < 0.004 { // 0.3% chance of random byte
		g.bytecode = append(g.bytecode, byte(g.rng.Intn(256)))
		g.currentGas += 3
		g.opcodeCount += 1 // Count the random byte as an opcode
		return true
	}

	// 99.6% chance of valid opcode
	return g.generateValidInstruction()
}

// generateValidInstruction generates a valid instruction that respects stack constraints
func (g *OpcodeGenerator) generateValidInstruction() bool {
	// Filter opcodes that we can actually execute given current stack state
	var candidates []*OpcodeInfo

	for _, op := range g.validOpcodes {
		if g.stackSize >= op.StackInput &&
			g.stackSize-op.StackInput+op.StackOutput <= 1024 && // Stack size limit
			g.currentGas+op.GasCost <= g.maxGas {
			candidates = append(candidates, op)
		}
	}

	if len(candidates) == 0 {
		// No valid candidates, try to add some stack items
		if g.stackSize < 1020 {
			// Add a PUSH1 with random data
			pushData := byte(g.rng.Intn(256))
			g.bytecode = append(g.bytecode, 0x60, pushData) // PUSH1
			g.stackSize += 1
			g.currentGas += 3
			g.opcodeCount += 1 // Count the PUSH1 opcode
			return true
		}
		return false // Can't generate anything
	}

	// Weight selection towards useful opcodes
	op := g.selectWeightedOpcode(candidates)

	// Generate the instruction
	sequence := op.Template()
	sequenceOpcodeCount := g.countOpcodesInBytecode(sequence)

	// Check both bytecode size and opcode count limits
	if len(g.bytecode)+len(sequence) > g.maxSize || g.opcodeCount+sequenceOpcodeCount > g.maxOpcodeCount {
		return false
	}

	g.bytecode = append(g.bytecode, sequence...)
	g.currentGas += op.GasCost
	g.opcodeCount += sequenceOpcodeCount // Count all opcodes in the generated sequence

	// Update stack state
	g.updateStackState(op)

	return true
}

// selectWeightedOpcode selects an opcode with weighted probability
func (g *OpcodeGenerator) selectWeightedOpcode(candidates []*OpcodeInfo) *OpcodeInfo {
	// Prefer PUSH operations when stack is low
	if g.stackSize < 5 {
		for _, op := range candidates {
			if g.isPushOpcode(op.Opcode) { // PUSH operations
				if g.rng.Float64() < 0.7 {
					return op
				}
			}
		}
	}

	// Prefer stack operations when stack is getting full
	if g.stackSize > 100 {
		for _, op := range candidates {
			if op.StackInput > op.StackOutput { // Operations that consume more than they produce
				if g.rng.Float64() < 0.6 {
					return op
				}
			}
		}
	}

	// Use weighted selection based on probability field
	totalWeight := 0.0
	for _, op := range candidates {
		totalWeight += op.Probability
	}

	if totalWeight == 0 {
		// Fallback to random selection if no probabilities set
		return candidates[g.rng.Intn(len(candidates))]
	}

	// Select based on weight
	randomValue := g.rng.Float64() * totalWeight
	currentWeight := 0.0

	for _, op := range candidates {
		currentWeight += op.Probability
		if randomValue <= currentWeight {
			return op
		}
	}

	// Fallback to last candidate
	return candidates[len(candidates)-1]
}

// updateStackState updates the virtual stack based on the executed operation
func (g *OpcodeGenerator) updateStackState(op *OpcodeInfo) {
	// Standard stack handling for other opcodes
	// Remove consumed items
	if g.stackSize >= op.StackInput {
		g.stackSize -= op.StackInput
	} else {
		g.stackSize = 0
	}

	// Add produced items
	g.stackSize += op.StackOutput
}
