// Code generated by 'yaegi extract github.com/ethereum/go-ethereum/crypto'. DO NOT EDIT.

package symbols

import (
	"crypto/elliptic"
	"github.com/ethereum/go-ethereum/crypto"
	"go/constant"
	"go/token"
	"math/big"
	"reflect"
)

func init() {
	Symbols["github.com/ethereum/go-ethereum/crypto/crypto"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"CompressPubkey":          reflect.ValueOf(crypto.CompressPubkey),
		"CreateAddress":           reflect.ValueOf(crypto.CreateAddress),
		"CreateAddress2":          reflect.ValueOf(crypto.CreateAddress2),
		"DecompressPubkey":        reflect.ValueOf(crypto.DecompressPubkey),
		"DigestLength":            reflect.ValueOf(constant.MakeFromLiteral("32", token.INT, 0)),
		"Ecrecover":               reflect.ValueOf(crypto.Ecrecover),
		"FromECDSA":               reflect.ValueOf(crypto.FromECDSA),
		"FromECDSAPub":            reflect.ValueOf(crypto.FromECDSAPub),
		"GenerateKey":             reflect.ValueOf(crypto.GenerateKey),
		"HashData":                reflect.ValueOf(crypto.HashData),
		"HexToECDSA":              reflect.ValueOf(crypto.HexToECDSA),
		"Keccak256":               reflect.ValueOf(crypto.Keccak256),
		"Keccak256Hash":           reflect.ValueOf(crypto.Keccak256Hash),
		"LoadECDSA":               reflect.ValueOf(crypto.LoadECDSA),
		"NewKeccakState":          reflect.ValueOf(crypto.NewKeccakState),
		"PubkeyToAddress":         reflect.ValueOf(crypto.PubkeyToAddress),
		"RecoveryIDOffset":        reflect.ValueOf(constant.MakeFromLiteral("64", token.INT, 0)),
		"S256":                    reflect.ValueOf(crypto.S256),
		"SaveECDSA":               reflect.ValueOf(crypto.SaveECDSA),
		"SigToPub":                reflect.ValueOf(crypto.SigToPub),
		"Sign":                    reflect.ValueOf(crypto.Sign),
		"SignatureLength":         reflect.ValueOf(constant.MakeFromLiteral("65", token.INT, 0)),
		"ToECDSA":                 reflect.ValueOf(crypto.ToECDSA),
		"ToECDSAUnsafe":           reflect.ValueOf(crypto.ToECDSAUnsafe),
		"UnmarshalPubkey":         reflect.ValueOf(crypto.UnmarshalPubkey),
		"ValidateSignatureValues": reflect.ValueOf(crypto.ValidateSignatureValues),
		"VerifySignature":         reflect.ValueOf(crypto.VerifySignature),

		// type definitions
		"EllipticCurve": reflect.ValueOf((*crypto.EllipticCurve)(nil)),
		"KeccakState":   reflect.ValueOf((*crypto.KeccakState)(nil)),

		// interface wrapper definitions
		"_EllipticCurve": reflect.ValueOf((*_github_com_ethereum_go_ethereum_crypto_EllipticCurve)(nil)),
		"_KeccakState":   reflect.ValueOf((*_github_com_ethereum_go_ethereum_crypto_KeccakState)(nil)),
	}
}

// _github_com_ethereum_go_ethereum_crypto_EllipticCurve is an interface wrapper for EllipticCurve type
type _github_com_ethereum_go_ethereum_crypto_EllipticCurve struct {
	IValue          interface{}
	WAdd            func(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int)
	WDouble         func(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int)
	WIsOnCurve      func(x *big.Int, y *big.Int) bool
	WMarshal        func(x *big.Int, y *big.Int) []byte
	WParams         func() *elliptic.CurveParams
	WScalarBaseMult func(k []byte) (x *big.Int, y *big.Int)
	WScalarMult     func(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int)
	WUnmarshal      func(data []byte) (x *big.Int, y *big.Int)
}

func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int) {
	return W.WAdd(x1, y1, x2, y2)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) Double(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int) {
	return W.WDouble(x1, y1)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) IsOnCurve(x *big.Int, y *big.Int) bool {
	return W.WIsOnCurve(x, y)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) Marshal(x *big.Int, y *big.Int) []byte {
	return W.WMarshal(x, y)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) Params() *elliptic.CurveParams {
	return W.WParams()
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) ScalarBaseMult(k []byte) (x *big.Int, y *big.Int) {
	return W.WScalarBaseMult(k)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) ScalarMult(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int) {
	return W.WScalarMult(x1, y1, k)
}
func (W _github_com_ethereum_go_ethereum_crypto_EllipticCurve) Unmarshal(data []byte) (x *big.Int, y *big.Int) {
	return W.WUnmarshal(data)
}

// _github_com_ethereum_go_ethereum_crypto_KeccakState is an interface wrapper for KeccakState type
type _github_com_ethereum_go_ethereum_crypto_KeccakState struct {
	IValue     interface{}
	WBlockSize func() int
	WRead      func(a0 []byte) (int, error)
	WReset     func()
	WSize      func() int
	WSum       func(b []byte) []byte
	WWrite     func(p []byte) (n int, err error)
}

func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) BlockSize() int {
	return W.WBlockSize()
}
func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) Read(a0 []byte) (int, error) {
	return W.WRead(a0)
}
func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) Reset() {
	W.WReset()
}
func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) Size() int {
	return W.WSize()
}
func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) Sum(b []byte) []byte {
	return W.WSum(b)
}
func (W _github_com_ethereum_go_ethereum_crypto_KeccakState) Write(p []byte) (n int, err error) {
	return W.WWrite(p)
}
